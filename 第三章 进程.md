## 3 进程



一个程序正在运行的一个实例就叫做一个进程，如果在你的屏幕上显示了二个终端窗口，此时你可能运行了相同的终端程序二次——这里你就有二个终端进程。每个终端窗口都大概运行了一个shell；每个shell是另一个进程。如果你在shell中调用了一个命令，对应的程序就是在一个新进程里执行；当那个结束的时候，shell进程会重新返回。

高级程序员经常在一个单独的应用程序中使用多进程协同操作，以使应用程序在马上完成多件事情，增强了程序的健壮性，并且利用了已经存在的程序。

这章描述的大多数进程操作函数与其他UNIX系统上的相似；大部分都定义在<unistd.h>头文件中；查阅操作手册确认每个函数。

 

**3.1 初识进程**

即使你坐在电脑旁边什么也不干，电脑中也有进程在运行。每个执行中的程序都使用一个或者多个进程。现在开始看看你有电脑上已经存在的进程。

 

**3.1.1 进程 ID**

在Linux系统上每个进程都有一个唯一的进程ID来标识，往往关联为pid。进程ID就是一个当新进程被创建的时候被Linux系统相继赋予的16位(二个字节)的数字。

每个进程都有一个父进程（除了特殊的init进程， 3.4.3 “僵尸进程”中描述），那么，你可以想象Linux系统上的进程像一棵整理过的树，init进程在它的根上。父进程ID，或者叫ppid，简单来说就是进程的父亲的进程ID。

如果在C和C++程序中用到进程ID，一般使用定义在<sys/types.h>头文件中的pid_t类型定义。程序可以通过getpid()系统调用获得正在运行的进程ID，也可能通过getppid()系统调用获得其父进程ID。例如，清单3.1程序，获得它的进程ID，和它的父进程的ID。

 

清单3.1 (print_pid.c)       打印进程ID

----

```c
#include <stdio.h>
#include <unistd.h>

int main()
{
	printf("The process ID is %d\n", (int)getpid());
	printf("The parent process ID is %d\n", (int)getppind());
	return 0;
}
```

----

 注意，如果你几次调用这个程序，会返回不同的进程ID，因为每次调用都是一个新的进程。然而，如果你每次调用都是在同一个shell中，那父进程ID（就是shell进程的进程ID）还是相同的。

  

**3.1.2 查看活动进程**

ps命令会显示系统上正在运行的进程。GNU/Linux上的ps命令版本有很多选项，因为它要尽可能兼容其他UNIX变种上的ps命令。这些选项控制列出哪些进程和每个进程显示什么信息。

默认调用ps显示进程是由在ps被调用的终端或者终端窗口中来控制的。例如：

> % ps
>
> PID   TTY                                  TIME  CMD
>
> 21693  pts/8             00:00:00  bash
>
> 21694  pts/8                         00:00:00    ps

此次调用显示了二个进程。第一个，bash，是运行在这个终端上的shell。第二个就是ps程序自身的一个运行实例。第一列，PID标签，显示每个进程ID。

想更详细的查看在你的GUN/Linux系统运行了什么，像这下面这样调用： 

> % ps –e –o pid,ppid,command

-e选项指示ps显示系统上所有正在运行的进程。-o pid,ppid,command告诉ps在这种情况下显示每个进程的信息，进程ID，父进程ID还有进程中运行的命令。

 



> *ps输出格式
>
> 配合**-o**选项，你可以指定以逗号分隔列表的方式输出你想要的进程信息。例如，***
>
> *ps –o pid**，**user**，**start_time**，**command**显示进程**ID**，拥有进程的用户的名称，进程启动的时间，运行在进程内的命令。查看**ps**的使用手册里所有简写的全称。你可以使用**-f(**完整列表**)**，**-l(**长列表**)**或者**-j(**工作列表**)**选项而获得不同于当前的三种列表格式。

这里给出了我的系统命令行里前几行和后几行的输出，取决于你的系统上运行的，你可能会看到输出不同：

> % ps –e –o pid,ppid,command
>
> PID        PPID       COMMAND
>
>   1              0              init  [5]
>
>  2              1             [kflushd]
>
>  3              1             [kupdate]
>
> …..
>
> 21725    21693    xterm
>
> 21727    21725    bash
>
> 21728    21727    ps –e –o pid,ppid,command

注意ps命令的父进程ID，21727，是bash的进程ID，也就是我调用ps的shell。bash的父进程ID反过来是21725，是shell运行在其中的xterm的进程ID。



**3.1.3 杀死一个进程**

你可以用kill命令杀死一个正在运行的进程。只需在简单的在命令中指定被杀死进程的进程ID。

kill命令通过向进程发送SIGTERM或结束信号[1][1]的方式工作。这会导致进程结束，至少执行中的程序会处理或者标记这个SIGTERM信号。信号在3.3节“信号”描述。

[1]: 你也可以使用kill命令向一个进程发送其他信号。这将在3.4节“进程中止”讲述。



**3.2 创建进程**

二种常规技术被用来创建进程。第一种相对简单，但是不常用因为它低效并且有很大的安全隐患。第二种技术更复杂一些，但是却更灵活，更快速，更安全。

 

**3.2.1 使用system**

在C标准库里的system函数提供了一个简单的方式在程序中执行系统命令，就如同命令已经被键入shell中。实际上，system函数创建了一个运行着的Bourne Shell（/bin/bash）子进程并且处理命令在shell中的执行。例如，清单3.2中程序调用ls命令显示根目录的内容，就如同你在shell中输入ls –l /一样：

 

清单3.2 (system.c) 使用system调用

----

```c
#include <stdlib.h>

int main()
{
	int return_value;
	return_value = system("ls –l /");
	return return_value;
}
```

----

 system函数返回shell命令的退出状态。如果shell自身不能运行，system返回127；如果发生其他错误，system返回-1。

       因为system函数是使用系统shell调用你的命令，它受系统shell的特征，限制，安全缺陷的影响。你不能依赖任何特定Bourne Shell版本的某个可用性。在许多Unix系统上，/bin/bash只是一个其他shell的符号链接。例如，大部分GNU/Linux系统，/bin/sh指向的是bash(Borune-Again Shell)，还有不同的GNU/Linux发行版使用不同版本的bash。例如，在root权限下，调用程序使用system函数，不同的GNU/Linux会有不同的结果。除非，使用更合适的fork和exec方法创建进程。

 

**3.2.2 使用****fork****和exec**

DOS和Windows 的API包含了spawn族函数。这些函数把要运行的程序的名字做为函数的参数，并且创建一个这程序的新的进程实例。Linux没有把这些一步做完的东西放在一个单个的函数中。Linux提供了一个函数，fork，它创建一个完全复制于其父进程的子进程。Linux提供了另外一组函数，exec族函数，它使一个特定的进程停止成为一个程序的实例，相反的会变成另外一个程序的实例。对于产生一个新进程，你首先使用fork做一份当前进程的拷贝。此时你再使用exec转换这些中的一个（进程）变成你想要生成的程序实例。

 

**调用fork**

当程序调用fork，一个叫做子进程的进程副本就会被创建。父进程在fork调用点继续执行程序。子进程，也会在相同的地方执行相同的程序。

那二个进程有何不同？首先，子进程是一个新进程并因此有了一个新进程ID，区别于父进程ID。一个程序分辨它在父进程还是子进程的方法就是调用getpid()。但是对于父进程和子进程fork函数提供不同的返回值——一个进程“进去”，二个进程“出来”，有不同的返回值。父进程的返回值是子进程的进程ID。子进程的返回是0。因为从未有进程的ID是0，这让分辨程序是在父进程运行还是子进程中运行变得很容易。

清单3.3给出了一个使用fork复制一个程序进程的例子。注意if语句的第一块仅在父进程中执行，else子句已经在子进程中执行了。

 

清单3.3 (fork.c) 使用fork复制程序的进程

----

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
    pid_t child_pid;
    printf("the main process ID id %d\n", (int)getpid());

    child_pid = fork();
    if (child_pid != 0)
    {
        printf("this is the parent process, with id %d\n", (int)getpid());
        printf("the child process ID is %d\n", (int)child_pid);
    }
    else
    {
        printf("this is the child process, with is %d\n", (int)getpid());
    }
    return 0;
}
```

----

**使用exec族函数**

exec（族）函数会用另一个程序替换掉正在一个进程中运行的程序。当一个程序调用了一个exec（族）函数，假设这个exec调用没有发生错误，那个程序进程就会马上停止执行转而从头开始执行一个新的程序。

在exec函数族里，它们的功能和调用方法稍有不同。

1)   名字包含字母p的函数（execvp和execlp）接受一个程序的名称，并且在当前执行路径下通过这个名称搜索这个程序；函数名中不包含p的函数，必须给定程序执行的全路径。

2)   在名称中含有字母v的函数（execv，execcvp和execve），接收以NULL结束字符串指针数组做为新程序的参数列表；名字包含字母l的函数（execl，execlp和execle），接收使用C语言可变参数机制的参数列表。

3)   名字中含有字母e的函数（execve和execle）接收附加的参数，是一个环境变量的数组。这个参数应该是以NULL结尾的字符串指针数组。每个字符串应该是“VARIABLE=value”这种形式。

因为exec是用另一个程序替换了正在调用的程序，它永远不会返回除非发生错误。

传递给程序的参数列表是与你从shell中运行程序指定的命令行参数是相同的。它们可以通过argc和argv参数被main函数访问。记住，当你在shell中调用一个程序，shell会设置参数列表第一个元素(argv[0])为程序的名字，第二个元素(argv[1])为第一个命令行参数，以此类推。当你在程序中使用exec也一样，应该传递函数的名称做为参数列表的第一个元素。

  

**同时使用fork和exec**

一个普遍的方式是首先从程序中分出一个可以运行子程序的进程，然后再执行子程序。在子进程中子程序替换掉了正在调用的程序，此时父进程的正在调用的程序依然继续执行是允许的。

清单3.4的程序跟清单3.2相似，使用ls命令列出根目录下的内容。不同于前一个例子的是，它直接调用ls程序，是传递给它l和/命令行参数，而不是通过shell调用它。

 

清单3.4 （fork_exec.c）同时使用fork和exec

----

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

/* 产生一个子进程运行一个新的程序，PROGRAM是要运行程序的名字
 * 当前路径是这个程序会搜索的路径，ARG_LIST是NULL结尾的字符串列表做为程序的参数列表
 * 返回产生进程的ID
 * */

int spawn(char *program, char **arg_list)
{
	pid_t child_pid;
	/* 复制这个进程 */
	child_pid = fork();
	if (child_pid != 0)
	{
		/* 这里是父进程 */
		return child_pid;
	}
	else
	{
		/* 此时执行PROGRAM， 在当前路径下搜索 */
		execvp(program, arg_list);
		/* execvp只在发生错误的时候返回 */
		fprintf(stderr, "an error occurred in execvp\n");
		abort();
	}
}

int main(int argc, char *argv[])
{
	/* 参数列表传递给ls命令 */
	char *arg_list[] = {
		"ls", /* argv[0], 程序的名称 */
		"-l",
		"/",
		NULL /* 参数列表必须以NULL结尾 */
	};
	/* 产生一个子进程运行ls命令， 忽略返回的子进程ID */
	spawn("ls", arg_list);

	printf("done with main program\n");
	return 0;
}
```

----

 

**3.2.3 进程调度**

Linux独立的调度父进程和子进程；不保证哪个进程第一个运行，或者运行多长时间，在Linux打断的它的之前，并且让其他进程运行。特别指出，没有，部分或者全部都可能运行在子进程里，在父进程结束之前[2][2]。Linux系统保证每个进程最终都会运行——没有进程会被完全切断运行资源。

你可以指定一个进程是次要的（优先级低的）——给一个较低的优先级——通过赋给它更高的值。默认的每个进程的优先级的值为0。一个更大的值就意味着进程被赋予了一个较低的优先级；相反，进程优先级值越小（是负数）获得的执行时间就越多。

想用非0的优先级值来运行一个程序，使用nice命令，使用-n选项指定优先级的值。例如，你可能会调用下面的命令“sort input.txt > output.txt”，一个过程稍长的排序操作，你可以降低它的优先级而不让它把你的系统拖得非常慢。

> % nice –n 10 sort input.txt >output.txt

你还可以在命令行中合作renice命令改变运行中进程的优先级。

要通过编程的方式来改变运行中进程的优先级，使用nice函数。它的参数是一个增量值。调用的时候会加到运行中进行的优先级值上。这就是意味着当你以root身份登陆的时候可以指定一个负值给nice和renice使用，并且只有在进程以root身份运行的时候你才可以传负值给nice函数。这可以防止普通用户从其他使用系统的用户那里霸占执行优先权。

 

**3.3 信号量**

在Linux上信号量是进程操纵与进程通信的机制。信号量是一个非常大的话题；这里我们只讨论部分最重要的用于操作进程的信号与方法。

一个信号就是一个发送给进程的特殊消息。信号是异步的。当一个进程接收到一个信号，进程就会马上处理这个信号，而不会执行完当前的函数甚至是一行代码。有若干表示不同意思的信号。每个信号形式由不同的信号量数值指定，但是在程序中，你通常可以通过信号名称引用它。在Linux上，这些都被定义在/usr/include/bits/signum.h（你不能直接在程序中直接包含这个文件，应该使用<signal.h>）。

[2]: 在3.1.4节“等待进程结束”，一个方法可以序列化当前的二个进程

当进程接收到一个信号的时候，它可能会根据信号的设置做几件事之一。对于每个信号，都有一个默认设置，它决定了如果程序没有指定其他行为，进程应该如何响应。对于大多数信号类型，程序可能会指定一些其他行为——可能忽略，或者指定一个信号处理函数来响应这个信号。如果信号处理被使用，当前执行的程序就会暂停，信号处理（函数）就会执行，当信号处理（函数）返回时，程序继续执行。

Linux系统将信号发给进程来响应特定的条件。比如，SIGBUS（总线错误），SIGSEGV（段违例）和SIGFPE（浮点异常）可能会被发送给进程，以阻止执行一个非法操作。这些信号的默认设置是结束进程并生成一个核心转储的文件。

一个进程也可以给另一个进程发送信号。这种机制的普遍用于通过发送SIGTERM或者SIGKILL信号来结束另一个进程[3][3]。另一个作用就是给一个运行的程序发送命令。二个“用户自定义”信号被保留用于这个目的：SIGUSR1和SIGUSR2。SIGHUP信号有时也用于这个目的，通常是唤醒程序或让程序重新读取配置文件。

sigaction函数用来设定信号的设置。第一个参数是信号数值。接下来二个参数是指向sigaction结构的指针。其中第一个包含了想要的对应信号数值的设置，同时第二个接收了前一个设置。第一个或者第二个sigaction结构中最重要的字段是sa_handler，它可以取下面三个值：

1）SIG_DFL， 指定了信号的默认设置。

2）SIG_IGN，指定信号应该被忽略。

3）一个信号处理函数指针。函数接收一个参数，就是信号数值，并且返回void

因为信号是异步的，当信号处理函数执行处理信号的时候，主程序可能会处于非常“脆弱”的状态。所以，你应该避免在信号处理函数中进行IO操作，或者调用大多数库和系统函数。

信号处理函数应该执行必要的最小化工作来响应信号，并且在此时返回控制权给主程序（或者结束程序）。大多数情况下，这仅仅记录信号发生的事实。主程序定时检测信号是否发生并据此产生响应。

信号处理被另一个信号传送打断是可能的。这乍一听像是不会发生，如果一旦发生，它就会是非常难以诊断和调试的程序。（这有一个竞态条件的例子，在第四章，“线程”，4.4节，“同步与临界区”）。所以，你应该非常注意你的程序在你的信号处理中做了什么。

[3]: 有什么不同？SIGTERM信号要求进程结束；进程可能会通过忽略或者掩蔽信号忽略这个请求。SIGKILL信号总是杀死进程，因为进程不能掩蔽和忽略SIGKILL信号。

甚至赋值给一个全局变量都可能是危险的，因为这个赋值可能是由二条或者更多的机器指令实现的，可能第二个信号会在它们之间发生，这样会将变量置于污染状态。如果你想在信号处理中使用一个全局变量标记信号，那么它应该是一个特殊的类型sig_atomic_t。Linux保证这种类型的变量赋值只会执行一条单独的指令而不会在中间打断。在Linux下，sig_atomic_t是一个普通的int；事实上就是赋值给int类型大小或更小的整型类型，或者赋值给指针，都是原子的。如果你想写一个程序能移植到任意标准的UNIX系统，那么就要使用sig_atomic_t做为这些全局变量。

在清单3.5中的程序框架，举个例子，使用信号处理函数统计程序接收SIGUSR1信号的次数，是程序保留使用的信号之一。

 

清单3.5 （sigusr1.c） 使用信号处理

----

```c
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

sig_atomic_t sigusr1_count = 0;

void handler(int signal_num)
{
	++sigusr1_count;
}

int main()
{
	struct sigaction sa;
	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = &handler;
	sigaction(SIGUSR1, &sa, NULL);
	
	/*Do some lengthy stuff here*/
	/*……*/
	printf("SIGUSR1 was raised %d times \n", sigusr1_count);
	return 0;
}
```

----

 

**3.4 进程终止**

正常情况下，进程会以二种方式中的其中一种结束。执行程序调用exit函数，或者程序main函数返回。每个进程都会有一个退出码：一个进程返回给父进程的数值。退出码通过exit函数或者main函数返回值赋值。

一个进程可能会响应信号非正常结束。例如，SIGBUS，SIGSEGV，SIGFPE信号被提及就会提前导致进程结束。其他信号可以用于显式的结束进程。当用户通过在终端键入CTRL+C结束程序时，SIGINT信号会被发送给进程。SIGTERM信号通过kill命令发送给进程。这二者的默认设置都是结束进程。通过调用abort函数，进程发送给它自己SIGABRT信号结束进程并产生一个核心文件。最强力的结束信号是SIGKILL，它可以立即结束进程并且不能通过程序锁定和控制。

这些信号中的任何一个都可以使用kill命令指定一个额外的命令行标志来发送；例如，通过发送SIGKILL信号来结束一个惹人烦的进程，调用下面的命令，pid是它的进程ID：

> %kill –KILL pid

从一个程序中发送信号，使用kill函数。第一个参数是目标进程的ID。第二个参数是信号的数值；使用SIGTERM信号模拟kill命令的默认行为。例如，child pid包含了子进程的进程ID，你可以像下面在父进程中通过调用kill函数结束子进程：

> kill(child_pid, SIGTERM);

想要使用kill函数，包含<sys/types.h>和<signal.h>头文件。

按照惯例，退出码通常用来指定程序是否正确执行。退出码为0表示程序正常执行，一个非0的退出码表示程序发生了一个错误。后一种情况下，返回的特殊值能给一些错误的本质以标示。坚持在你的程序中使用这种约定是好的，因为其他的GNU/Linux系统也采取这种行为。例如，shell采取这种约定，当你通过&&（逻辑与）和||（逻辑或）操作符连接多个程序时。所以，除了发生错误，你应该显式的在你的main函数中返回0。

大多数shell中，都可以使用特殊的$?变量获取最近执行程序的退出码。这里有一个例子，调用ls命令二次，在每次调用完命令后显示其退出码。第一个里，ls命令执行正确并且返回0退出码，第二个里，ls遇到了错误（因为命令行指定的文件名不存在），所以就返回了非0退出码。

> % ls
>
> bin  coda  etc lib  misc  nfs  proc  sbin  usr
>
> boot  dev  home lost+found  mnt  opt root  tmp  var
>
> % echo $?
>
> 0
>
> % ls bogusfile
>
> ls: bogusfile : No such fileor diretory
>
> % echo $?
>
> 1            

需要注意，即使exit函数的参数类型和main函数的返回类型都是int，但是Linux不会保留返回码为全32位。事实上，你可以使用的退出码只有0到127，退出码超过了128就有特殊的意思——当一个进程被信号结束的时候，它的退出码是128加上信号的信号数值。

 

**3.4.1 等待进程结束**

如果你敲了并且运行了在清单3.4的关于fork和exec的例子，你可能会发现ls程序的输出出现在“主程序”已经完成后。那是因为ls运行所在的子进程已经预先的独立于父进程。因为Linux是多任务操作系统，进程看起来像是同时运行，你不能预知ls程序将有机会先于或者迟于父进程执行。

在某些情况下，父进程等待一个或者多个子进程执行完是有必要的。这些可以由wait家庭的系统调用来完成。这些函数允许你等待一个进程执行完，并且可以由父进程取回子进程的结束信息。有四种不同的wait家族系统调用；你可以选择获取少的或者多的进程退出信息，并且你还可以选择是否关注子进程的结束。

 

**3.4.2 wait 系统调用**

最简单的函数就是简单的wait。它锁定正在调用的进程直到其中一个子进程退出（或者发生错误）。它通过一个整型指针参数返回一个状态码，从这里你可以得知子进程如何退出的信息。例如，WEXITSTATUS宏可以得到子进程退出码。

你可以使用WIDEXITED宏从一个子进程退出状态确定进程是正常退出（通过exit函数或者main返回状态）还是终止于一个未处理的信号。后一种情况可以通过WTERMSIG宏从它的退出状态得知让其终止的信号数值。

这里再次给出取自fork和exec例子中的main函数，这一次，父进程调用wait等待子进程直到其执行完ls命令。

```c
int main(int argc, char *argv[])
{
	int child_status;
	/* 参数列表传递给ls命令 */
	char *arg_list[] = {
		"ls", /* argv[0], 程序的名称 */
		"-l",
		"/",
		NULL /* 参数列表必须以NULL结尾 */
	};
	/* 产生一个子进程运行ls命令， 忽略返回的子进程ID */
	spawn("ls", arg_list);
	
	/* 等待子进程结束 */
	wait(&child_status);
	if (WIFEXITED(child_status))
	{
		printf("the child process exited normally, with exit code %d\n", WEXITSTATUS(child_status));
	}
	else
	{
		printf("the child process exit abnormally.\n");
	}
	printf("done with main program\n");
	return 0;
}
```

还有几个类似的系统调用在Linux系统上也是可用的，它们更灵活或者可以提供更多的关于子进程的信息。waitpid函数能用来等待指定的子进程，而不是任意的子进程退出。wait3函数返回退出子进程的CPU使用情况统计，wait4函数允许你指定额外的关于等待进程的选项。

 

**3.4.3 僵尸进程**

如果当父进程正在调用wait函数的时候，子进程结束，子进程完全消失并且它的结束状态通过wait调用传递给了父进程。但是当子进程结束父进程不是正在调用wait时发生了什么？仅仅是简单的消失吗？不是，因为此时关于它（子进程）的结束信息——比如它是否正常退出等，如果这样的话，它的退出状态将会丢失。也就是，当一个子进程结束时，它变成了一个僵尸进程。

僵尸进程就是已经退出但是没有清除的进程。父进程是有清除属于其的僵尸子进程责任的。wait函数也这么做，但是它没有必要跟踪在等待它之前你的子进程是否一直执行。假设举个例子，一个程序分出一个子进程执行一些其他的计算，此时调用wait。如果子进程在那个点没有结束，父进程应该锁定wait调用直到子进程完成。如果在父进程调用wait调用之前子进程执行完成，这个子进程就变成了僵尸进程。当父进程调用wait，僵尸子进程结束状态就会被提取，子进程已经被删除，wait调用会立刻返回。

如果父进程没有清除它的子进程会发生什么？它们会一直留在系统中，如僵尸进程。清单3.6的程序中分出一个子进程并马上结束，并且此时（父进程）睡眠一分钟，根本不清除子进程。

 

清单3.6 (zombies.c)  制造一个僵尸进程

----

```c
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main(void)
{
    pid_t child_pid;

    /*产生一个子进程*/
    child_pid = fork();
    if (child_pid > 0)
    {
        /*这是父进程， Sleep一分钟*/
        sleep(60);
    }
    else
    {
        /*这里是子进程， 立刻退出*/
        exit(0);
    }
    return 0;
}
```

----

试着把这个文件编译成名为make-zombie的可执行程序。运行它，并且在它运行期间，在另一个窗口中调用如下命令列出系统进程：

> % ps –e –o pid, ppid,stat, cmd

这列出了进程ID， 父进程ID， 进程状态和进程命令行。观察那些，除了make-zombie父进程，还有列出了另一个make-zombie进程。它就是子进程；注意它的父进程ID是make-zombie主进程的进程ID。子进程被做为<defunct>标记，并且它的状态码是Z，意思就是僵尸。

当make-zombie主程序结束当父进程退出并且根本没调用wait会发生什么？僵尸进程会一直留在这？不会——试着再运行ps，发现二个make-zombie进程都消失了。当一个程序退出，它的子进程被继承于一个特殊的进程，就是一直以进程ID为1运行的init程序（当Linux启动时第一个运行的进程）。这个init什么自动清除所有继承它的僵尸子进程。

 

**3.4.4 异步方式清除子进程**

如果使用子进程简单的用exec执行另一个程序，在父进程中立即调用wait是很好的，它（父进程）会锁定直到子进程结束。但是往往你想要父进程继续执行，同时一个或多个子进程异步执行。但是你怎么确定那些已经完成的进程已经被清除，而不致于留下僵尸进程消耗系统资源？

一个建议就是父进程定时的调用wait3或者wait4来清除僵尸子进程。为此调用wait不是很好用，因为如果没有进程结束，这个调用就会一直锁定到一个子进程完成。但是，wait3和wait4会带一个额外的标志参数，可以传递标志值WNOHANG。有了这个标志，这个函数就是运行在非锁定模式——它会清除一个已经结束的子进程，如果它只有一个或者不存在而只是返回。前一种情况，这个调用会返回已经结束子进程的进程ID，后一种情况返回0。

一种比较优雅的解决方式是当子进程结束的时候通知父进程。有几种方法可以做这件事，使用方法将会在第五章“进程间通信”讨论，幸亏Linux允许你使用信号这样做。当一个子进程结束时，Linux系统会给父进程发送SIGCHLD信号。这个信号的默认设置是什么也不做，这就是之前你没有注意到它的原因。

因此，一种简单的方式通过处理SIGCHDL信号来清除子进程。当然，当你清除子进程的时候，如果需要它的退出信息的话，保存子进程的退出信息还是很重要的，因为子进程一旦使用wait被清除，退出信息将不再可用。清单3.7是一个程序使用SIGCHLD处理函数来清理它的子进程。

清单3.7 (sigchld.c)         通过处理SIGCHLD信号清理子进程

----

```c
#include <signal.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>

sig_atomic_t child_exit_status;

void clean_up_child_process(int signal_number)
{
	/* 清除子进程 */
	int status;
	wait(&status);
	/* 保存退出状态到一个全局变量 */
	child_exit_status = status;
}

int main(int argc, char *argv[])
{
	/* 通过调用clean_up_child_process处理SIGCHLD信号 */
	struct sigaction sigchild_action;
	memset(&sigchild_action, 0, sizeof(sigchild_action));
	sigchild_action.sa_handler = &clean_up_child_process;
	sigaction(SIGCHLD, &sigchild_action, NULL);

	/* 这里做些事情，包括分出子进程 */
	return 0;
}
```

----

注意信号处理子程序保存子进程退出状态在一个全局变量里。从主程序中可以直接访问它，因为这个变量在信号处理程序中被赋值，它的类型是sig_atomic_t。