### 2  编写优质的GNU Linux软件

这章涵盖了大多数Linux程序员开发过程中会用到的基本编程技术。在下面的教程中，你会学到如何写出在Linux系统完美运行并且是有良好交互体验的软件。

**2.1  与运行环境交互**

当你第一次学习C/C++的时候，你就知道一个叫做main的特殊函数，是整个程序的主要入口点，操作系统在运行你写的程序的时候自动寻找并提供相应的设备，这个设备就是帮助程序与用户和操作系统交互通信的。你应该知道main的二个名为argc和argv的参数，通常用来接收程序输入，还应该了解到用来控制台输入输出的stdin和stdout（在C++里是cin和cout流），这些特性都是c和c++本身支持的。在某些方面来讲，这些特性是它们（C和C++）与GNU/Linux系统交互的根本。当然，GNU/Linux也提供其他与操作环境交互的方式。

**2.1.1 参数列表**

通常运行程序的方式就是在shell命令窗口输入程序的名字并回车。根据不同使用场景，还可以在输入程序名称之后加上一个或者多个以空格分开的单词作为程序的附加信息，这个附加信息，就叫命令行参数（参数中如果带空格，可以使用转义字符转义）。通常这被称做程序的参数列表，但它（参数）不是一定要在shell命令行中指定的。在第三章“进程”中，你可看到另一种调用程序的方式，就是程序可以直接指定另一个程序做为参数列表。

程序在shell中被调用的时候，参数列表已经包含了整个输入命令行输入的内容，其中包括了程序的名称和所有在命令行已经提供的参数。打个比方，如下所示，在shell窗口中使用ls命令显示根目录下的内容和对应文件的大小：

> % ls –s / 

这个ls程序的参数列表接收了三个参数，第一个就是在命令行里指定的叫ls程序自己的名字，第二个和第三个参数列表元素就是二个命令行参数 –s和/。

程序的main函数可以通过其参数argc和argv访问参数列表（如果你不打算用这[二个参数]，可以直接忽略它们），第一个参数argc是一个整型，用来存储参数列表中所包含参数数量，第二个参数argv，是一个字符指针数组，数组的大小就是argc，数组元素是指向参数列表里面的每一个以NULL结束的字符串。

查看argc和argv的内容就像使用命令行参数一样简单，如果你对参数列表中的程序名称不感兴趣，那别忘了跳过参数列表中的第一个元素。

清单2.1 为你演示如何使用argc和argv

```c
#include<stdio.h>
int main(int argc,char *argv[])
{
    printf(“The name of this program is ‘%s’.\n”,argv[0]);
    printf(“This program was invoked with %darguments.\n”, argc - 1);
    
  	int I;
	printf(“The arguments are: \n”);
    for (i = 1; i < argc; i++)
    {
		printf(“  %s\n”, argv[i]);
	}
	return 0;
}
```



**2.1.2  GNU/Linux命令行约定**

几乎所有的GNU/Linux程序都遵从命令行参数解释执行的一些约定。程序参数可以分为二类：选项（或者叫做标志）和其他参数。当其他参数为程序提供输入（如实例数据，输入文件等）的时候，选项参数就会改变程序的行为。

选项有下面二种形式：

1)    由单个连字符(即半角中划线)与单个字符（通常是一个小写或者大写的字母）构成的“短选项”。短选项可以快速的输入。

2)    由二个连字符开始，后跟多个小写或者大写字母与连接符组成的选项名字这二者构成的“长选项”。长选项更加易读易记（例如在shell脚本里）。

通常一个程序所支持的选项都会提供短和长二种形式，前者是后者的简化。例如，一般的程序都可以解释-h和—help选项，而且它们的作用完全相同。正常情况下，在shell中调用程序，可以直接在程序名称后接任意多个选项，而有些选项只希望后接一个参数。比如有好多程序里–output foo的意思就是，程序输出至一个名为foo的文件内。很多选项后可能还会跟着一些输入文件或者输入数据等一些命令行参数。

例如，ls –s /命令是显示根目录的内容，-s选项改变了ls的默认行为，令其显示每个文件内容大小（kb为单位）。而/参数告诉ls应该列出哪个目录的内容。--size与-s选项是相同的作用，所以还可以像ls –size /这样调用而达到同样的目的。

GNU 编码标准列出了一些常用命令行选项的名字，如果你也打算提供一些类似的选项，使用编码标准里约定的名字是一个好想法，如你想要你的程序表现得更像其他那些程序并且更易于用户使用，你可以在大多数Linux系统命令行里调用如下命令来查阅关于命令行选项的GNU 编码标准参考：

> % info “(standards) User Interface”

 

**2.1.3 使用getopt_long**

解析命令行选项非常麻烦，幸运的是GNU的C库提供了一个函数可以让这个过程在c和c++程序中变得更简单（尽管仍然有点儿烦人），这个getopt_long函数可以解析长选项和短选项。如果想使用这个函数，需要包含头文件<getopt.h>

举例来说，写一个程序接受三个如表2.1里列出的三个选项：

表2.1

短形式                         长形式                                                作用

----

-h                                   --help                                            显示使用摘要和退出

-o filename                    --outputfilename                            指定输出文件

-v                                   --verbose                                      打印详细信息

----

此外，该程序还接收0或者多个输入文件名称做为命令行参数。

使用getopt_long，必须提供二个数据结构，第一个是包含合法短形式选项的字符串，每一个都是单个的字母。如果选项需要一个参数，那么其后需要跟一个冒号来表示。对于当前这个程序而言，字符串ho:v就表示合法的选项是-h，-o，-v，而且这些选项的第二项后需要跟一个参数。

为了指定可用的长形式选项，你需要构造一个元素类型为struct option的数组。每个元素对应一个长形式的选项，它有四个字段，通常第一个字段就是这个长形式的选项的名字（不带二个连字符的字符串），第二个如果选项带参数就是1，其他情况是0，第三个是NULL，第四个是一个常量字符，用来指定与长选项相同意义的短选项缩写，数组的最后一个元素所有的字段都是0，可以像下面样儿来构造数组：

```c
const struct option long_option[] =
{
    {“help”, 0, NULL, ‘h’},
    {“output”, 1, NULL, ‘o’},
    {“verbose”, 0, NULL, ‘v’},
    {NULL, 0, NULL, 0}
};
```

调用getopt_long函数，通过argc和argv参数把它(长选项数组与短选项字符串)传给main函数，字符串描述了短选项，struct option数组描述了长选项。

1)    每次调用getopt_long，它解析单个的选项，返回这个选项的的短选项字母，如果没找到就返回-1。

2)    通常，都会在循环中调用getopt_long来处理用户指定的所有的选项，可以在switch语句中来处理指定的选项。

3)    如果getopt_long遇到非法的选项（你没有指定合法的长或者短选项），它会打印出错误信息并且返回一个问号字符，大多数程序在这种情况下会退出程序，并随后显示出使用信息。

4)    当处理带参数的选项的时候，全局变量optarg就会指向这段参数文本。

5)    在getopt_long函数解析完所有的选项之后，全局变量optind就会包含第一个不是选项的参数(argv里)索引值。

清单2.2给出来示例教你如何使用getopt_long处理程序参数：        

清单2.2 (getopt_long.c) 使用getopt_long

----

```c
#include <stdio.h>
#include <getopt.h>
#include <stdlib.h>

/*程序的名称*/
const char *program_name;

/* 在流上（通常为标准输出或者标准错误）打印使用信息，并且以指定退出码退出，没有返回值 */
void print_usage(FILE *stream, int exit_code)
{
	fprintf(stream, "Usage: %s options [inputfile....]\n", program_name);

	fprintf(stream, 
			"	-h  --help				Display this usage information.\n"
			"	-o	--output filename	Write output to file.\n"
			"	-v --verbose			Print verbose messages.\n"
			);
	exit(exit_code);
}

/* 主程序入口点，ARGC包含了参数列表的参数数量， ARGV是指向它们的数组 */
int main(int argc, char *argv[])
{
	int next_option;
	/* 一个列出短选项的字符串 */
	const char *short_options = "ho:v";
	/* 包含长选项的结构数组 */
	const struct option long_options[] = 
	{
		{"help", 0, NULL, 'h'},
		{"output", 1, NULL, 'o'},
		{"verbose", 0, NULL, 'v'},
		{NULL, 0, NULL, 0}
	};
	/* 接收程序输出的文件名，置NULL则是输出为标准输出 */
	const char *output_filename = NULL;
	/* 是否显示详细信息 */
	int verbose = 0;

	/* 记住程序和名称，然后结合在信息里 名称存放在argv[0]中*/
	program_name = argv[0];
	do
	{
		next_option = getopt_long(argc, argv, short_options, long_options, NULL);
		switch (next_option)
		{
			case 'h': /* 输入-h或者--help */
				/* 用户需要帮助信息，在标准输出里打印它，并且以退出码0退出程序（正常退出） */
				print_usage(stdout, 0);
				break;
			case 'o': /* 输入-o或者--output */
				/* 这个选项带参数 输出文件的名字 */
				output_filename = optarg;
				break;
			case 'v': /* 输入-v或者--verbose */
				verbose = 1;
				break;
			case '?': /* 用户指定了非法选项 */
				/* 向标准错误打印使用信息，并且使用退出码1退出程序（表明非正常终止程序） */
				print_usage(stderr, 1);
				break;
			case -1: /* 选项完成 */
				break;
			default: /* 其他意想不到的发生 */
				abort();
				/* code */
		}
		
	}while (next_option != -1);

	/* 选项完成 OPTIND指向第一个非选项参数， 做为演示，在verbose指定的时候打印这个参数 */

	if (verbose)
	{
		int i = 0;
		for (i = optind; i < argc; i++)
		{
			printf("Arguments: %s\n", argv[i]);
		}
	}
	return 0;
}
```

----

使用getopt_long 可能看起来做了很多工作，但是如果你自己写代码来解析命令行选项可能会更长。getopt_long函数是非常精巧的可以灵活的指定任意接受的各种选项。然而，远离那些更高级的特性和底层的选项结构描述是个好主意。



**2.1.4  标准输入输出**

标准C库提供了标准输入输出流（分别是stdin和stdout），这些都会被scanf，printf还有其他函数用到。在传统的UNIX中，使用标准输入输出是Linux程序的习惯。它允许多个一系列的程序通过shell管道重定向输入和输出（可以查看你shell的帮助手册来了解它具体的语法）。

同时C标准库也提供了stderr标准错误流，程序可以用标准错误流替代标准输出打印出警告和错误信息，这可以使用户更好的区分正常输出和错误信息，例如，将标准输出重定向到文件，同时在控制台打印错误信息。fprintf函数被用来打印到stderr，比如：

```c
fprintf(stderr, (“Error: ….”));
```

这三种流也可以由底层UNIX I/O命令（read，write等）通过文件描述符访问。这些文件描述符分别是0对应stdin， 1对应stdout，2对应stderr。

当调用程序的时候，有的时候需要同时将标准输出和标准错误重定向到文件或者管道。这个语法可以适用在各种shell中，对于Borune类的shell（包括bash，大多数Linux发行版默认的shell），语法形式是：

> % program >output_file.txt?>&1
>
> % program 2 > &1 | filter        

这个2>&1的语法表示的意思是，文件描述符2(stderr)被合并到文件描述符1(标准输出)中，需要注意的是，这个2>&1必须在文件重定向之后（如第一个例子）或者必须在一个管道重定向之前。

需要知道stdout是缓冲的，写入stdout的数据直到缓冲区满，程序关闭或stdout关闭之后才会发送到控制台（如果是重定向，也可能是发送到其他设备），你可以像下边这样儿调用函数强制刷新缓冲区：

```c
fflush(stdout);
```

与之相反，stderr是不缓冲的，写入stderr的数据会直接显示在控制台。[1][1]

这会产生让人意想不到的结果。例如，这个循环不会每秒打印一个句点，因为句点是缓冲的，所以会在缓冲满了的时候会直接打印出一串句点：

```c
while(1)
{
    printf(“.”);
    sleep(1);
}
```

而在下面这个循环中，句点就会每秒出现一次：

```c
while(1)
{
    fprintf(stderr, “.”);
    sleep(1);
}
```



**2.1.5  程序退出码**

当程序退出的时候，会用退出码来指明它的退出状态。这个退出码是个小的整型值。按照惯例，退出码为0说明着程序成功运行，非0值表示程序发生了错误。一些程序用不同非0值的退出码来区别出各种错误。

在大多数的shell中，可以使用特殊的变量$?获取上一次运行的程序的退出值。这有调用二次ls命令在每次调用后打印退出值的例子，第一种情况ls正确执行并且返回了退出码0，第二种情况ls命令遇到了错误（因为命令行里指定的文件名不存在），于是就返回了非0的退出码。

> % ls /
>
> bin coda etc lib misc nfs proc sbin usr
>
> boot dev home lost+found mnt opt root tmp var
>
> %echo $?
>
> 0
>
> %ls bogusfile
>
> ls:bogusfile: No such file or directory
>
> %echo $?
>
> 1

[1]: 在C++中，区别依次是cout和cerr。注意的是endl刷新流并打印一个换行符，如果你不想刷新流（比如出于性能的原因），就使用常量字符’\n’代替。


C或者C++程序退出码，是由main函数的返回值来指定的。还有其他方式在程序非正常情况下结束时给程序提供和指定退出码（使用信号量）。这将会在第三章讨论。


**2.1.6  运行环境**

GNU/Linux为每个运行的程序提供运行环境。这个运行环境就是变量/值对的集合。环境变量名和对应的值都是字符串。按照惯例，环境变量全部用大写字母来命名。你可能已经熟悉几个公共的环境变量，如下：

1)    USER 包含了你当前的用户名

2)    HOME 包含了你当前主目录的路径

3)    PATH 包含了冒号分隔的目录列表，你所调用的命令Linux就会在这些目录中寻找

4)    DISPLAY包含了XWindow服务器从图形化XWindow窗口程序中显示的名字和显示的数字 

Shell也像其他程序一样有自己的运行环境。Shell提供了一种直接查看和修改环境变量的方法。调用printenv程序在shell中打印当前环境变量。各种shell都有不同的的内置语法来操作环境变量。下面的是针对于Bourne风格shell的语法。

> % echo $USER
>
> samuel
>
>  % echo $HOME
>
>  /home/samuel 

你可以使用export命令把shell变量导出到环境变量中，比如，设置EDITOR环境变量，可以使用下面的命令：

> % EDITOR=emacs
>
> export EDITOR

或者简写为：

> % export EDITOR=emacs

在程序中，可以使用<stdlib.h>里的getenv函数获取环境变量。函数接受一个变量名称参数，并以字符串返回相应的环境变量值，如果在环境中没定义对应的变量就返回NULL。如要设置或者清除环境变量，分别使用setenv和unsetenv函数。

列举出所有的环境变量有一些难度，要这么做的话，必须访问定义在GNU C库里特殊的名为environ的全局变量。这个变量类型是char**，是指向以NULL结束的字符串数组的指针。每个字符串包含了形式为VARIABLE=VALUE的环境变量。

如清单2.3的程序，简单的用循环通过environ数组打印所有的环境变量。

清单2.3 (print_env.c) 打印运行环境

----

```c
#include <stdio.h>

/* ENVIRON变量包含了整个环境 */
extern char **environ;

int main(int argc, char *argv[])
{
    char **var;

    for (var = environ; *var != NULL; var++)
    {
        printf("%s\n", *var);
    }
    return 0;
}
```

----

不要直接手动去修改你的environ变量，如果要修改，尽量用setenv和unsetenv函数去操作对应的环境变量。

通常一个新程序开始运行，它其实是继承了这个调用它的程序环境的副本（如果在交互环境下调用，就是shell）。举例来说，运行在shell里的程序可能就会检查你在shell中设置的环境变量。

环境变量通常被用来给程序传递配置信息。举个例子，你正在编写连接互联网服务器并获取一些信息的程序。这个程序应该方便的在命令行中指定服务器的名字。但是，假设服务器名字不是用户经常去更改的东西。你可以使用特殊的环境变量——叫SERVER_NAME——指定要连接的服务器名称，如果服务器名称环境变量不存在，就会使用一个默认值。程序的应该会像清单2.4所示：        

清单2.4 (client.c) 网络客户端程序的一部分

----

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    char *server_name = getenv("SERVER_NAME");
    if (server_name == NULL)
        /* 环境变量SERVER_NAME没有设置，刚使用默认值 */
        server_name = "server.my-company.com";
    printf("accessing server: %s\n", server_name);
    /* 访问服务器  */
    return 0;
}
```

----

假设程序名字叫client，假定你没有设置SERVER_NAME变量，程序就直接使用指定的默认服务器名称：

> % client
>
> accessing server: server.my-company.com

但是现在指定不同的服务器名称很容易

> % export SERVER_NAME=backup-server.elsewhere.net
>
> % client
>
> accessing server:backup-server.elsewhere.net 



**2.1.7  使用临时文件**

有时候程序需要生成一个临时文件暂存一些大的数据，或者是用临时文件给另外一个程序传递数据。在GNU/Linux系统中，临时文件放在/tmp目录下。使用临时文件的时候，你要注意以下几个问题：

1)    程序可能同时有多个实例在运行(被相同的或者不同的用户运行)。这些实例应该使用不同的临时文件名，防止它们读写产生冲突。

2)    临时文件应该设置权限，防止未被授权的用户通过修改或者替换临时文件的方式干涉程序的运行。

3)    程序中临时文件的生成方式应该不能被外部所能预测，也就是说，攻击者可以利用在（程序）测试一个文件名是否在使用和打开一个新文件之间的延迟。

GNU/Linux提供了解决这些问题的函数mkstemp和tmpfile（除了几个功能不能），这取决于你是否想处理临时文件到另一个程序，是否想使用UNIX I/O(open, read, write)或者C库里的I/O流函数(fopen, fprintf)。

 

**使用mkstemp**

mkstemp函数从文件名模板里创建出一个唯一的临时文件名，创建的这个临时文件权限只允许当前用户访问和打开文件读写。文件名模板是一个以XXXXXX（六个大写X）结尾的字符串；mkstemp函数用字符替换X以便文件名是唯一的。返回值是一个文件描述符；使用write系函数来对临时文件进行写操作。

mkstemp函数生成的文件不会自动删除，临时文件不再需要的时候需要手动删除（程序员应该仔细的清理临时文件；不然，/tmp文件系统最后会满，系统会无法运行）。如果临时文件只是在内部使用而不是在另一个程序中再处理，马上调用unlink是个好办法。unlink函数会删除对应文件的目录入口，但是由于文件系统中文件引用计数的关系，如果不再打开那个文件的文件描述符，这个临时文件就不会被移除，这样，你的程序可以继续使用这个临时文件，而且会在你关闭文件描述符的时候文件自动消失。因为Linux在程序结果的时候会关闭文件描述符，所以即使你的程序非正常结束，临时文件也会被移除。

这对函数在mkstemp示例的清单2.5中，一起使用这些函数将会使内存缓冲写到临时文件，之后再读取回来的操作变得非常简单。

清单2.5 （temp_file.c）使用mkstemp

----

```c
#include <stdio.h>
#include <stdlib.h>

/* 使用write_temp_file创建的临时文件句柄，在这个实现代码中，它仅仅是个文件描述符 */
typedef int temp_file_handle;

/* 从BUFFER中向临时文件中写入LENGTH bytes 这个临时文件会马上unlink，返回一个句柄给临时文件*/
temp_file_handle write_temp_file(char *buffer, size_t length)
{
    /* 创建文件和文件名，XXXXXX会被替换掉而生成一个唯一的文件名 */
    char temp_filename[] = "/tmp/temp_file.XXXXXX";

    int fd = mkstemp(temp_filename);
    /* 马上unlink这个文件， 以便能在文件描述符关闭的时候就会删除这个文件 */
    unlink(temp_filename);
    /* 首先向临时文件中写入一些字节 */
    write(fd, &length, sizeof(length));
    /* 现在自己写入数据 */
    write(fd, buffer, length);
    /* 使用文件描述符做为临时文件的句柄 */
    return fd;
}

/*
 *读取由write_temp_file函数创建的TRMP_FILE临时文件的内容，返回值就是这些内容新分配的buffer，调用者需要释放
 *LENGTH是设置内容的长度，以byte为单位，临时文件已经被移除了
 */
char *read_temp_file(temp_file_handle temp_file, size_t *length)
{
    char *buffer;
    /* 这个TEMP_FILE文件句柄是临时文件的文件描述符 */
    int fd = temp_file;
    /* 重新定位到文件开头 */
    lseek(fd, 0, SEEK_SET);
    /* 在临时文件中读取数据的长度 */
    read(fd, length, sizeof(*length));
    /* 为读取的数据分配buffer */
    buffer = (char *) malloc(sizeof(*length));
    read(fd, buffer, *length);
    /* 关闭文件描述符， 这样就能使临时文件消失 */
    close(fd);
    return buffer;
}
```

----

**使用tmpfile函数**

如果你要使用C标准库的IO函数而且也不需要通过临时文件与其他的程序传递信息，你可以使用tmpfile函数。这个函数创建并打开一个临时文件，且返回这个文件的文件描述符。这个临时文件是unlink的，当文件描述符闭关闭(使用fclose)或者程序结束的时候就会自动删除。

GNU/Linux还提供了几个其他生成临时文件和临时文件名的函数，包括mktemp，tmpnam，和tempnam。尽量不要使用这些函数，因为它们会给已经提到过的可靠性和安全性带来问题。

 

**2.2  防御性编程**

能写出在正常情况下正确运行的程序是很难的；写出在失败的情况下还能“表现优雅”的程序就更难了。这小节示范一些编程技巧，可以在运行中的程序中尽早的寻找出bug，发现并避免更多的问题。

本书下面给出的示例代码会有意的跳过比较普遍的错误检查和修复检查代码，因为这些代码会掩盖给出的最基本功能。但是在11章的最后一个示例中，“一个GNU/Linux应用示例”，会返回来示范如何使用这些技巧写健壮的程序。

 

**2.2.1  使用assert断言**

一个好的做法就是在编写应用程序的过程中尽早注意那些会明显导致程序运行失败的bug和未预期的错误。这会帮你在开发和循环测试的时候更早的找到bug。直到用户使用的时候程序错误才会显露出来，这是程序最大的失败。

最简单的方法就是使用C标准库中的assert宏检查不可预知的情况。这个宏的参数是一个布尔表达式，如果表达式结果为假，在打印出包括源代码文件名，行号，对应表达式文本的错误信息后，程序会在此中止。这个宏在程序的内部大量一致性检查中是非常有用的。比如，使用assert检查函数参数的合法性，检查函数调用的前置和后置条件（C++中的方法调用），检查非预期的返回值。

每个使用的assert不但可以做为一个条件的运行期检查，还可以在源文件内部作为程序操作的文档说明。如果你的程序包含一个assert(条件)也就是告诉阅读你的代码的人在该程序中这个条件应该总是为真，如果条件不为真，可能就会导致程序出现bug。

对一些要求性能的代码中，像assert这种运行期检查会导致严重的性能问题。在这种情况下，可以通过在编译器命令行中使用-DNDEBUG这个已经定义的NDEBUG宏来编译你的代码，设置了NDEBUG，assert会在预处理时就会被移除，这仅在必要时出于性能原因的时候是个好办法，不过这只能用作性能优先的源文件。

因为可能会在预处理时移除掉assert宏，要留心你所使用的任何assert表达式都应该没有副作用。尤其需要注意的是，不要在assert表达式中调用函数，变量赋值，或者使用修改类的操作符，比如++。

举个例子，在一个循环里重复调用一个叫do_sonmething的函数。这个do_something函数成功返回0失败返回非0。但是你不希望它在程序中调用失败，于是你暂时这么写：

```c
for (I = 0; I < 100; i++)
    assert(do_something() == 0);
```

不过，你可能会发现这个运行期检查会导致一个很大的性能问题并且决定马上重新用定义DNEBUG宏来重新编译。这将会移除所有的assert调用，所以其中的表达式将不会被计算并且do_something函数也永远不会被调用。你可以用下面写的代替：

```c
for(I = 0; I < 100; i++)
{
    int status = do_something();
    assert(status != 0);
} 
```

另一件需要记住的事就是不应该使用assert测试用户非法输入。用户不喜欢应用程序出现故障的时候提示一条令人费解的错误信息，甚至是对于输入无效都是如此的响应。你应该总是检查无效输入并且在响应输入的时候给出友好的提示信息。仅在内部运行的时候使用assert检查。

下面的是一些使用assert很好的地方：

1)    检查空指针。例如，作为非法函数参数。由{assert(pointer != NULL)}生成错误信息，

> Assertion ‘pointer != ((void *)0)’ failed. 

如果你的程序对一个空指针进行解引用操作，会提供比错误信息更有用的信息

> Segmentationfault (core dump)[注，通常译做：段错误，核心已转储]

2)    检查函数参数的情况，比如，一个函数被调用且仅接受一个叫做foo的正数参数，可以像下面这样在函数体开头调用assert：

`assert(foo > 0);`

这会帮你发现函数错误，并且还可以让阅读函数源代码清楚函数的参数是有限制的。 

尽情在代码里使用assert吧！



**2.2.2  系统调用失败**

我们之中大多数最初都学过如何编写按标准流程运行的程序。我们把程序划分为任务和子任务，每个函数通过调用对应的其他函数完成相应的子任务来完成最终任务。给其适当的输入，我们期望这个函数能给出一个正确的输出并且没有副作用。

计算机硬件和软件的并存打破了这个理想化的梦想。计算机有资源限制；硬件故障；多个程序同时运行；用户和程序员们失误；经常在应用程序和操作系统的边界间它们自己表现出这些情况。因此，当系统调用访问系统资源的时候，执行I/O，或者出于其他目的，要明白不但要知道调用成功发生什么，还要明白何时、如何会发生调用失败是非常重要的。

系统调用会在很多情况下失败，例如：

1)    系统可能耗尽了所有资源（或者程序使用了超过系统分配给单个程序的资源上限），比如，程序试着分配非常大的内存，向硬盘写入非常多的数据，或者同时打开多个文件。

2)    当程序尝试执行一个它并没有权限的操作，Linux系统会锁定对应的系统调用。比如，程序试图向只读文件写入数据，访问另一个进程的内存，或者杀死另一个用户的进程。

3)    系统调用的的参数可能是非法的，有可能是用户的非法输入，也可能是程序的bug。例如，程序可能会给系统调用传递了无效的内存地址，或者是无效的文件描述符。也可能是程序用打开目录的方式去尝试打开普通文件，或者传递了一个普通文件名给了期望接收目录名的系统调用。

4)    系统调用失败也可能因为外部程序的原因。这种情况经常发生在系统调用访问硬件设备的时候。设备可能自身出错，或者不支持某种特定的操作，也有可能是硬盘上没有安装对应的设备驱动。

5)    系统调用被外部事件打断，如传递信号。这并不表示调用完全失败，需要的时候（继续系统调用）重启系统调用是调用程序的责任。

大量使用系统调用写得好的程序，通常比程序主要工作更多的代码都是用来发现、处理错误和其他的异常的情况的。

 

**2.2.3  系统调用中的错误代码**

大部分系统调用在操作成功后返回0值，操作不成功返回非0值（虽然有很多不同的返回值约定，比如，malloc返回空指针表示函数调用失败，使用系统调用要仔细读使用手册）。尽管这些信息已经提供了足够的信息来确定程序是否应该继续运行，但是它未必能够提供足够的从错误中恢复的信息。

大多数系统调用一旦失败都会使用一个名为errno的特殊变量来存储额外的错误信息[2][2]。当调用发生失败时，系统就会设置errno值来说明发生了什么错误。因为所有的系统调用都会使用这同一个errno变量存储错误信息，所以应该在调用失败后马上将errno的值保存到其他变量中。因为这个errno变量的值在你下次使用系统调用的时候就会被覆盖。

错误值是整型值；可能的值都有对应的宏定义，所有的都被转换成以大写E开头的——例如，EACCES和EINVAL。总是使用宏引用errno值而不是使用整型值。如果想使用errno值的宏定义要包含<errno.h>头文件。

GNU/Linux提供了一个转换函数strerror，返回一个errno错误代码的更容易被理解和使用的描述字符串。如果想使用strerror要包含<string.h>头文件。

GNU/Linux也提供了perror函数，直接通过stderr错误流打印错误描述。在打印错误描述之前传递给perror一个字符串前缀，通常都是包含失败的函数名。如果想使用perror，则需要包含<stdio.h>头文件。

下面的代码片段试图打开一个文件；如果打开失败，会打印错误消息并退出程序。注意，open调用操作成功返回一个文件描述符，操作失败返回-1。

```c
fd = open(“input_file.txt”, O_RDONLY);
if (-1 == fd)
{
    /*打开失败，打印消息并退出*/
    fprintf(stderr, “error opening file: %s\n”, strerror(errno));
    exit(-1);
}
```

根据你的程序和系统调用的性质，对应的动作一旦失败就会打印出错误信息，取消操作，中止程序，重试，甚至忽略错误。想方设法在代码中包含处理所有失败情况的逻辑是非常重要的。

[2]: 实际上，由于线程安全的原因，errno是做为一个宏实现的。但是它用起来像一个全局变量。

可能有一个错误代码是需要你特别注意的，尤其是使用I/O函数，就是EINTR错误码。有些函数，如read，select和sleep，调用会非常耗时。这些被看作是“锁定”函数，因为在调用完成之前程序运行是锁定的。然而，如果程序被这些调用中的一个锁定的时候接收了一个信号，函数调用没有完成操作就会返回。这种情况，errno就会被设置为EINTR，通常这种情况下你需要再次尝试一下这个系统调用。

下面给出的代码段使用chown调用改变由用户user_id和path确定的文件的所有者。如果调用失败，程序就会根据errno值做出操作。要注意在发现程序中可能导致核心文件生成的bug时，要用assert或者abort退出程序。这对事后调试是很有帮助的，对于某些不可恢复的错误，比如内存溢出，我们应该使用exit和一个非0退出值退出，因为此时一个核心文件不是很有用的。

```c
rval = chown(path, user_id, -1);
if (rval != 0)
{
    /*保存错误代码，因为在下次调用的时候这个值会被覆盖*/
    int error_code = errno;
    /*操作不成功，chown返回-1*/
    assert(rval == -1);
    /*检测errno值，并做出对应动作*/
    switch(error_code)
    {
        case EPERM:/*权限拒绝*/
        case EROFS:/*只读文件系统路径*/
        case ENAMETOOLONG:/*路径过长*/
        case ENOENT:/*路径不存在*/
        case ENOTDIR:/*路径一部分不是目录*/
        case EACCES:/*路径一部分不可访问*/
            /*文件发生错误，打印错误信息*/
            fprintf(stderr, “error changing ownership of %s: %s\n”, 
                    path, strerror(error_code));
            /*不结束程序，用户可能会再次选择其他文件*/
            break;
        case EFAULT:
            /*路径包含了非法内存地址，这可能是一个bug*/
            abort();
        case ENOMEM:
            /*核心内存溢出*/
            fprintf(stderr, “%s\n”, strerror(error_code));
            exit(1);
        default:
            /*其他未预期的错误代码，我们应该处理所有可能的错误代码，如果我们丢掉一个，那就是一个bug*/
            abort();
    }
}
```

 你可直接使用这个代码，如果调用成功，它的表现是相同的。

```c
rval =chown(path, user_id, -1);
assert(rval== 0);
```

但是它调用失败的时候，这个选择对错误报告，错误处理，或者错误恢复没有任何影响。

是否使用第一个方案或者第二个方案，或者介于二者之间的方案，取决于你的程序的错误检测和错误恢复。

 

**2.2.4  错误和资源分配**

通常，系统调用失败，它会对应的取消当前的操作而不是结束整个程序因为它可能会在错误中恢复，一种方法就是当前函数返回，传递返回值给调用者来表明发生了什么错误。

如果你决定从函数中返回，要确定在函数里之前分配成功的资源要首先释放，这点是非常重要的。这些资源包括，内存，文件描述符，文件指针，临时文件，同步对象等。否则，如果你的程序继续运行，在失败之前分配的资源就会生泄漏。

考虑这样的例子，一个函数从文件中读取数据到缓冲区，这个函数可能会按以下步骤：

1.    分配缓冲区。

2.    打开文件。

3.    读取文件到缓冲区

4.    关闭文件。

5.    返回缓冲区。



如果文件不存在，步骤2会失败，合适的操作可能就是从函数中返回NULL，但是如果缓冲区在步骤1中就被分配好了，这就会有内存泄漏的风险。你必须记得在某个不返回的控制流中释放已经分配的缓冲区。如果在步骤3出错，那不但要在返回之前释放缓冲区，还必须要关闭文件。

清单2.6给演示如何写这个函数。

清单2.6 (readfile.c) 在非正常条件下释放资源

----

```c
#include <fcntl.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

char *read_from_file(const char *filename, size_t length)
{
    char *buffer;
    int fd;
    ssize_t bytes_read;
    /*分配缓冲区内存*/
    buffer = (char *)malloc(length);
    if (buffer == NULL)
        return NULL;
    /*打开文件*/
    fd = open(filename, O_RDONLY);
    if (fd == -1)
    {
        /*打开失败，返回前释放buffer内存*/
        free(buffer);
        return NULL;
    }	
    /*读取数据*/

    bytes_read = read(fd, buffer, length);
    if (bytes_read != length)
    {
        /*读取失败，返回前释放buffer，关闭文件*/
        free(buffer);
        close(fd);
        return NULL;
    }
    /*没出任何问题，关闭文件，并返回buffer*/
    close(fd);
    return buffer;
}
```

----

Linux系统会在程序退出后清理分配的内存，打开的文件，和一些其他资源，所以在调用exit之前没有必要释放缓冲区和关闭文件。但是你需要手动释放其他共享资源，比如像临时文件和共享内存这样潜在的生存周期比程序还长的资源。 

 

**2.3  编写和使用库**

实际上所有的程序都会链接一个或者多个库。任意使用C函数（如printf或者malloc）的程序都会链接C运行时库。如果你的程序有图形界面，那它将会链接窗口图形库。如果你的程序使用数据库，数据库供应者会提供给你让你方便访问数据库的库。

在这些情况下，你需要决定是使用动态链接还是静态链接。如果你选择使用静态库链接，那么程序的体积会变得非常大，程序的更新也会非常困难，但会非常容易布署。如果你使用动态链接，你的程序会非常小，更新也会相对容易，但是难于布署。这小节会解释如何进行动态和静态链接，更详细的权衡和研究这二种链接方式，并且给出一些“经验规则”来决定哪种链接方式对你来说更好。

 

**2.3.1 归档**

归档（或者静态库）可以将目标文件集合打包为单个文件（归档大致与windows系统下的.Lib文件相同）。当你为链接器提供了归档，链接器会搜索归档寻找它需要的文件，解压并链接它们到你的程序里。这与直接提供这些目标文件没什么不同。

你可以使用ar命令创建归档。归档文件按惯例使用.a作为扩展名，而不是像普通目标文件使用.o扩展名。下面教你如何合并test1.o和test2.o到一个名为libtest.a单独归档中：

> % ar cr libtest.a test1.o test2.o

cr标志告诉ar命令创建一个归档[3][3]，现在你就可以像在第一章，入门指南，链接目标的1.2.2节中描述的，用gcc或者g++的-ltest选项链接这个归档库文件。

当链接器在命令行中解析出归档库时，它会搜索归档里所有已经处理却没有定义的目标文件里引用的所有的符号（包括函数和变量）。定义了这些符号的目标文件从归档中解压出来并且被包含进最终的可执行文件中。因为链接器在命令行里解析归档的时候才会搜索归档，通常合理的做法是将归档放在命令行的最后，假设test.c包含了清单2.7的代码，app.c包含了清单2.8的代码。

清单2.7 (test.c) 库内容

----

```c
int fun()
{
	return 3;
}
```

 

清单2.8 (app.c) 使用库函数的程序

----

```c
int main()
{
	return f();
}
```

----

[3]: 你可以使用其他标志从归档中移除一个文件，或者执行在归档上执行其他操作。这些操作通常很少用到，但是仍然记录在ar的使用手册中。

现在假设test.o与一些其他目标文件合并生成libtest.a归档库。下面的命令不能正常工作：

> % gcc –o app –L. –ltest app.o
>
> app.o: In function ‘main’:
>
> app.o(.text+0x4): undefined reference to‘f’
>
> collect2: ld return 1 exit status

这个错误信息提示，尽管libtest.a已经包含了f的定义，但链接器仍然找不到它。是因为在首次遇到libtest.a的时候它就被搜索，而这个时候，链接器没有看到任何关于f的引用【注，意为在链接的时候如果找到未处理的引用，那么链接器会向后查找，而此时，libtest已被搜索过了，再向后找不到对应的引用，就会报错】。

相反，如果我们使用下面这行，就不会出现错误信息：

> % gcc –o app app.o –L. –ltest

原因就是在app.o中的对f的引用，导致链接器在libtest.a归档中包含了test.o目标文件。

 

**2.3.2  共享库**

共享库（也称做共享目标文件，或者动态链接库）类似包含了一组目标文件的归档。但是，有很大差别。最基本的差别是，当动态库被链接到一个程序中时，当前在共享库中的代码是不会真正的被包含到最终的可执行文件中的。也就是仅仅在程序运行的时候才会引用共享库。如果系统里的几个程序链接了同一个共享库，它们都将引用这个共享库，但是没有任何一个共享库会被包含进程序中。所以，动态库在所有链接它的程序之间“共享”。

第二个重要的不同就是共享库不仅仅是一个目标文件的集合，而且链接器还不会只会选择那些需要满足的未被定义的引用。也就是，构成动态库的目标文件被合并进单个目标文件中，致使链接动态库的程序总是包含了在动态库中的所有的代码，而不仅仅包含需要的那一部分。

创建一个共享库，需要使用编译器-fPIC选项编译出组成这个库的目标文件,如下：

> % gcc –c –fPIC test1.c

这个fPIC选项告诉编译器你将使用test1.o作为共享目标的一部分。

**位置无关代码（PIC）**

PIC就是位置无关代码的意思。在动态库中的函数可能会被加载到不同程序中的不同的地址，所以在共享目标中的代码被加载的时候必须不依赖地址或者位置，这种做法对做为程序员的你，除了你要记得使用-fPIC选项编译你要在共享库使用的代码之外，其他对你没有任何影响。

此时你可以用下面的命令把目标文件合并到共享库中：

> % gcc –shared –fPIC –o libtest.sotest1.o test2.o test2.o

选项-shared告诉链接器要生成共享库，而不是普通的可执行文件。共享库文件使用.so后缀，意为共享对象。像静态归档一样，名字通常以lib开头表示这个文件是库文件。

链接共享库就像链接静态归档一样。例如，下面这个命令将会链接libtest.so，前提是这个库文件在当前目录或者在系统标准库搜索路径中：

> % gcc –o app app.o –L. –ltest

假设libtest.a和libtest.so都是可用的。此时链接器必须要在二者中选其一。链接器会搜索每个目录（第一个就是由-L选项指定的那些，接下来的是标准库目录那些）。当链接器找到了包含libtest.a或者libtest.so的目录，链接器就会停止搜索目录。如果二者中的只有一个在当前目录，链接器就会直接选择当前目录这个库。否则，链接器就会选择共享库，除非你明确指定使用哪个。你可以使用-static选项强制使用静态归档库。例如，即使libtest.so共享库也是可用的，下面这行命令也只会使用libtest.a归档，

> % gcc –static –o app app.o –L. –ltest

ldd命令会显示链接到可执行文件里的动态库。当可执行文件运行时这些库应该是可用的。注意，ldd命令会列出一个额外的叫ld-linux.so的库，它是GNU/Linux动态链接机制里的一部分。



**使用LD_LIBRARY_PATH**

当你使用共享库链接程序时，链接器不会把共享库的完整路径放到可执行程序里。相反的它只会放共享库的名字。当程序真正运行的时候，系统就会搜索共享库并加载它。系统默认只会搜索/lib和/usr/lib。假如要链接到你程序的共享库没有安装在这些目录中，系统找不到这个共享库，就会拒绝执行此程序。

一种解决方法就是在链接程序的时候使用-Wl,-rpath选项。例如像下面这样使用：

> % gcc –o app app.o –L. –ltest –Wl,-rpath,/usr/local/lib

此时，当app程序运行的时候，系统就会搜索/usr/local/lib目录下去找所需要的库。

另一种解决方法就是当运行程序的时候设置LD_LIBRARY_PAT环境变量。就像PATH环境变量一样，LD_LIBRARY_PATH也是一个冒号分隔的目录列表。如果LD_LIBRARY_PATH是/usr/local/lib:/opt/lib，此时/usr/local/lib和/opt/lib目录就会先于标准/lib和/usr/lib目录被查找。如果设置了LD_LIBRARY_PATH环境变量你也应该注意，在程序构建可执行文件的时候，链接器会搜索由-L选项指定的附加的目录[4][4]。

 

**2.3.3  标准库**

即使在你链接程序的时候没有指定任何库，程序也也会使用一个共享库。那是因为GCC会自动为你链接C标准库，libc。C标准库数学函数被包含在libc里；它们在一个单独的库里，libm库，你需要显式的指定它。例如，编译链接使用了类似sin或者cos三角函数的compute.c程序，你必须像下边这样进行编译：

> % gcc –o compute compute.c –lm

如果你编写C++程序并且使用C++或者g++命令来编译它，也会自动链接标准C++库，libstdc++。



**2.3.4  库依赖**

某一个库经常依赖另一个库。例如，许多GNU/Linux系统包含libtiff库，它含有读写TIFF格式图像文件的函数。这个库反过来使用了libjpeg（普通JPEG图片）和libz（普通压缩）这二个库。

清单2.9展示了一个使用libtiff库打开TIFF图像文件文件的小程序。

清单2.9 (tifftest.c)  使用libtiff

----

```c
#include <stdio.h>
#include <tiffio.h>

int main(int argc, char **argv)
{
    TIFF *tiff;
    tiff = TIFFOpen(argv[1], “r”);
    TIFFClose(tiff);
    return 0;
}
```

----

保存源文件为tifftest.c。编译程序并链接libtiff。在链接命令行指定-ltiff

> % gcc –o tifftest tifftest.c –ltiff

默认会找到libtiff的共享库版本，也就是/usr/lib/libtiff.so。因为libtiff使用了libjpeg和libz，所以这二个共享库也会被引入进来（共享库可以指向另一个它依赖的共享库）。为了验证这些，使用ldd命令：

> % ldd tifftest
>
> libtiff.so.3 => /usr/lib/libtiff.so.3(0x4001d000)
>
> libc.so.6 => /lib/libc.so.6 (0x40060000)
>
> libjpeg.so.62 => /usr/lib/libjpeg.so.62(0x40155000)
>
> libz.so.1 => /usr/lib/libz.so.1 (0x40174000)
>
> /lib/ld-linux.so.2 => /lib/ld-linux.so.2(0x40000000) 

从另一方面来说，静态库不能指向其他库。如果决定使用libtiff的静态版本，要在命令行指定-static，你就会出现未解析的符号这个错误：

> % gcc –static –o tifftest tifftest.c –ltiff
>
> /usr/bin/../lib/libtiff.a(tif_jpeg.o):In function ‘TIFFjpeg_error_exit’:
>
> tif_jpeg.o(.text+0x2a): undefined reference to‘jpeg_abort’
>
> /usr/bin/../lib/libtiff.a(tif_jpeg.o): In function‘TIFFjpeg_create_compress’:
>
> tif_jpeg.o(.text+0x8d): undefined reference to‘jpeg_std_error’
>
> tif_jpeg.o(.text+0xcf): undefined reference to‘jpeg_CreateCompress’

想静态链接这个程序，你必须自己指定其他二个库：

> % gcc –static –o tifftest –ltiff –ljpeg –lz

[4]: 你可能在某些在线文档中看到过引用LD_RUN_PATH的，不要相信你看到的。这个变量在GNU/Linux下不会做任何实质性的事情。

有时候二个库会互相依赖，换句话说，也就是第一个归档会引用定义在第二个归档里的符号，反之亦然。这种情况通常发生在不专业的设计中，但是有时也会发生。在这种情况下，你可以在命令行中多次指定某一个单独的库，链接器会在它每次出现的时候再次搜索这个库。例如，下面这行就会让libfoo.a被搜索多次。

> % gcc –o app app.c –lfoo –l bar –lfoo

这样即使libfoo.a引用了libbar.a里的符号，或者libbar.a引用了libfoo.a里面的符号，程序也会链接成功。

 

**2.3.5  优点和缺点**

现在你知道了所有关于静态归档和共享库的东西，你可能跃跃一试想用一下了。但是这里还有几个重要的事项需要注意。

共享库一大优点就是在安装程序的系统上节省空间。如果你安装10个程序并且他们都使用了同一个共享库，此时你便可以通过使用共享库节省很多空间。如果你使用静态归档代替，归档就会被包含进10个程序中。所以，使用共享库节省磁盘空间。如果你的程序在网上下载，它还可以缩短下载的时间。

一个相关的共享库的优势是，用户可以仅升级库而不是升级依赖它们的所有程序。例如，假设你做了个管理HTTP连接的共享库。许多程序可能都依赖这个库。如果你在这个库中发现了一个bug，你可以升级这个库。 同时所有依赖这个库的程序就全部修正了这个bug；你不必像静态归档那样重新链接所有的程序。

这些优势可能会让你认为应该总是用动态库。然而却有大量的原因存在，以使用静态归档。实际情况就是一个共享库的升级会影响依赖它的所有的程序，这会变成一个缺点。例如，你正在开发一个“关键业务”软件，你可能会选择链接静态归档，以便共享库的升级不会影响你的程序（否则，用户可能会升级共享库，因此中断你的程序， 就等客户抓狂吧）。

如果不能在/lib和/usr/lib里安装你的库文件，你一定三思是不是要用共享库了（如果你希望用户用户不使用管理员权限安装你的软件，那你将不能安装库文件到这些目录）。特别指出，如果你不知道最终库应该放在哪，选项Wl，-rpath将不会工作。询问用户设置LD_LIBRARY_PATH就意味对他们多出额外的一步，因为每个用户不得不单独做这个，这是个很大的负担。

对于你要发布的程序， 你必须权衡这些优点和缺点。



**2.3.6  动态装载和卸载**

有时你可能想要在运行加载一些并没有明确指出链接的那些代码，例如，考虑一个支持插件模块的应用，如web浏览器。浏览器允许第三方开发者创建插件提供额外的功能。第三方开发者创建共享库并把它们放在一个已知位置。Web浏览器会自动加载在那些库中的代码。

在Linux下通过dlopen函数使用这个功能。你可以通过像下边这样调用dlopen打开一个名为libtest.so的共享库。

`dlopen(“libtest.so”, RTLD_LAZY);`

(第二个参数是指明如何绑定在动态库中符号的标志，如果你想了解更多，可以查阅dlopen的在线帮助手册，但是RTLD_LAZY通常就是你想要的设置)， 为使用动态装载函数，包含<dlfcn.h>头文件，链接使用-ldl选项加入libdl库。

这个函数的返回值是void *， 做为使用共享库的句柄，你可以传递这个值给dlsym函数获得这个动态库中已经加载的函数的地址。例如，如果libtest.so中定义了一个叫my_function的函数，你可以按如下方式调用它：

```c
void * handle = dlopen(“libtest.so”,RTLD_LAZY);
void (*test)() = dlsym(handle, “my_function”);
dlclose(handle);
```

这个dlsym函数也可以用于获取共享库中静态变量的指针。

如果调用不成功，dlopen和dlsym都会返回NULL，那种情况下，你可以调用dlerror(没有参数)获取一条描述这个问题的可读错误信息。

dlclose函数卸载共享库，严格意义上讲，dlopen函数只加载尚未加载的共享库。如果库已经被加载过，dlopen只是简单的增加这个库的引用次数。同样的，dlclose减去引用次数，并且在引用次数到0的时候卸载这个库。

如果你在你的共享库代码中使用了C++，你可能需要用“extern C”链接指示符来定义你想在其他地方访问的函数和变量。例如，如果C++函数my_function在一个共享库中，并且你想要用dlsym访问它，你应该像如下定义：

`extern “C” void foo();`

这防止C++编译器弄乱了函数名称，C++编译器会更改函数名称foo为不同的，看起来有趣的编码函数信息的名字。C编译器不会弄乱名字;它直接使用你给出的任何一个函数和变量名。
