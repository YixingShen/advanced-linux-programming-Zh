### 管理Linux系统



**6**  设备

**7**  */proc*文件系统

**8**  Linux系统调用

**9**  内联汇编代码

**10** 安全

**11** GNU/Linux示例程序







### 6 设备

Linux系统像其他操作系统一样，内部通过叫做**设备驱动**的模块化的软件组件与硬件进行通信。设备驱动隐藏了操作系统与硬件通信的协议具体细节，同时给系统提供了标准的接口与硬件设备进行通信。

Linux系统下，设备驱动是内核的一部分，既能以静态链接的方式加入内核，也可以按需加载的方式成为内核模块。设备驱动以内核的一部分来运行，并且不会直接访问用户进程。但是Linux系统提供了可以和设备驱动通信的机制—通过一个"类文件对象"—操作硬件。这些文件对象都出现在文件系统中，并且程序也能打开这些文件对象，也可以像正常文件一样进行写操作。无论是通过Linux提供的低级I/O操作还是标准C语言库的I/O操作，都可以通过操作这些"类文件对象"与硬件通信。

Linux也提供几个类文件对象来直接与Linux内核通信，而不是通过设备驱动与Linux内核通信。这些文件不直接与硬件相链接。而是提供多种专门的接口给应用和系统程序。

> **访问设备时要小心!**
>
> 这章讲的技术是直接访问正运行在Linux内核中的设备驱动，并且通过它们来访问连接到系统内的硬件。使用这些技术时需要小心，如果滥用可能会损坏GNU/Linux系统。
>
> *详情看侧边 "块设备的危害"*。

### 6.1 设备类型

设备文件不同于普通文件—它们并不是在文件系统中的一块在磁盘上的数据区域。向设备文件中读取与写入数据相当于与对应的设备驱动通信，再由设备驱动到底层设备。设备文件有二种形态:

- `字符设备`表示这是可以读取或者写入一系列数据字节流的硬件设备。串行和并行接口，磁带设备，终端设备，还有声卡都属于字符设备。
- `块设备`表示这是可以在固定大小的块内读写数据的硬件设备。不像字符设备，块设备提供对存储在设备数据中随机访问功能。磁盘驱动器就是一个块设备。

平常的应用程序都不会用到块设备。虽然磁盘驱动器是块设备，但是每个磁盘分区里的内容通常都包含一个文件系统，同时这个文件系统挂载在GNU/Linux根文件系统树上。只有实现文件系统的内核代码才需要直接访问块设备；应用程序访问磁盘上的内容都是通过标准文件和目录来完成。

> **块设备危害**
>
> 块设备提供了直接访问磁盘驱动器数据的功能。即使大多数GNU/Linux系统都设置了非根进程不能直接访问这些设备，但是根进程还是可以通过改写磁盘上的内容对块设备造成严重危害。通过向磁盘块设备写入内容，程序可以修改或者毁掉文件系统控制信息，甚至是磁盘分区表和主启动记录，这样就直接导致驱动或者整个系统全部瘫痪。访问这些设备时一定要非常小心。

应用程序有时候会使用字符设备，接下来几节我们会讨论关于字符设备的内容。

### 6.2 设备编号

Linux标识设备使用二个数字: `主设备编号`和`次设备编号`。主设备编号用来表示哪个驱动对应哪个设备。对应主设备编号的驱动是固定写在内核代码中的。注意相同的主设备编号可能对应二个不同的设备，一个字符设备一个是块设备。次设备编号用来辨别单独的设备或者单独由一个驱动来控件的组件。

比如，主设备编号为3的对应系统中的主IDE控制器。IDE控制器可以有二个设备(磁盘，磁带，或者CD-ROM驱动器)附加在里面；"主"设备有一个次设备编号为0，"从"设备有一个次设备编号是64。"主"设备上单独的分区(假设设备支持分区)依次由次设备编号1，2，3这样类推。"从"设备上单独的分区依次由次设备编号65，66，67这样类推。

主设备编号都列在Linux内核代码文档中。在多数的GNU/Linux发行版中，可以在`usr/src/linux/Documention/devices.txt`中找到。`/proc/devices`这个特殊的入口列出了当前内核已加载的设备与驱动相对应的主设备编号(查看第七章，"/proc 文件系统"，获得更多关于`/proc`文件系统的入口)。

###  6.3 设备入口

设备入口很多时候都一个标准的文件。你可以用`mv`命令移动这个文件，也可以用`rm`命令删除这个文件。如果你用`cp`命令拷贝这个文件，其实就是从设备中读取字节数据(假设这个设备支持读取)再写入到目标文件。如果你想覆盖设备入口，你只需要向对应的设备写入字节数据即可。

你可以用`mknod`命令(使用`man 1 mknod`查看手册)或者调用`mknod`系统函数(使用`man 2 mknod`查看手册)在文件系统中创建设备入口。在文件系统中创建设备入口并不会自动让到对应的设备驱动或者硬件设备立即可用；如果有了设备入口，这仅仅是与驱动器通信的入口。只有超级用户进程才能通过`mknod`命令或者`mknod`系统调用创建块设备和字符设备。

使用`mknod`命令创建设备，第一个参数指定入口文件在文件系统中的路径。第二个参数，`b`表示是块设备，`c`表示是字符设备。第三个和第四个参数分别对应主设备编号与次设备编号。例如下这个命令创建一个字符设备入口，名字是`lp0`，路径是当前目录，主设备编号是6，次设备编号是0。这些数字表示Linux系统上的第一个并行端口。

```shell
% mknod ./lp0 c 6 0
```

记住只有超级用户进程能创建字符设备与块设备。所以你必须以`root`用户登陆才能成功调用这个命令。

`ls`命令用来显示指定的设备入口。如果你用`ls`命令的时候带了`-l`或者`-o`选项，那么命令每行的输入第一个字符就表示当前入口的类型。记住`-`(中划线)表示是标准文件，`d`表示是目录。类似，`b`表示块设备，`c`表示字符设备。`ls`还会在平常普通文件输出文件大小的位置输出主设备编号与次设备编号。举例，可以看一下刚才我们创建的块设备:

> % ls -l lp0
> crw-r-----    1 root     root       6,   0 Mar  7 17:03 lp0

在程序中，你可以通过`stat`确定文件系统入口是块设备还是字符设备，并获取其设备编号。可以在附录B中查看B.2小节，"stat"。

移除设备入口使用`rm`。这并不会删除设备或者设备驱动；只是简单的移除文件系统中的设备入口。

> % rm ./lp0

### 6.3.1 /dev 目录

按惯例，GNU/Linux系统在会`/dev`目录下包含全部Linux已知的字符设备与块设备入口。在`/dev`目录下的所有入口都由标准的设备名字与主次设备编号组成。

例如，主设备包含主IDE控制器，其主次设备编号分别是3和0，有一个标准名字是`/dev/hda`。如果这个设备支持分区，其中第一块分区的次设备编号就是1，标准名字就是`/dev/hda1`。你可以在你自己的系统上检查一下:

> % ls -l /dev/hda /dev/hda1
> brw-rw----    1 root     disk       3,   0 May  5  1998 /dev/hda
> brw-rw----    1 root     disk       3,   1 May  5  1998 /dev/hda1

同样的，`/dev`还有一个我们之前用的的并行端口字符设备:

> % ls -l /dev/lp0
> crw-rw----    1 root     daemon     6,   0 May  5  1998 /dev/lp0

大多数情况你不需要自己调用`mknod`创建设备入口，直接使用`/dev`下的入口就可以了。非超级用户别无选择，因为不能自己创建设备入口，只能使用先前存在的设备入口。通常只有系统管事员与开发者在在特殊的硬件上工作的时候才需要创建设备入口。大多数GNU/Linux系统发行版都包含了工具帮助管理员创建正确名字的标准设备入口。

### 6.3.2 通过打开文件访问设备

你如何使用这些设备?比如字符设备，使用它十分简单:就像打开正常文件一样打开这个设备，然后向其中读写就可以了。你甚至可以用普通文件用的`cat`命令，或者你所使用shell的重定向语法，向这个设备发送数据或者读取数据。

举例说明，假设现在你电脑的第一个并行商品上连接了一个打印机，你可以直接向`/dev/lp0`发送文件，就可以所文件打印出来了。假设要打印的内容在`document.txt`文件中，则可以像下面这样调用:

> % cat document.txt > /dev/lp0

前提是你必须有向这个设备入口写入的权限，这个操作才会成功；在多数GNU/Linux系统中，只有`root`用户和打印机守护进程(`lpd`)才有权限向这个设备入口写入文件。同时你向打印机发送了什么内容，打印机就会打印出什么内容。有些打印机会打印出发送给它的普通无格式文本，而有些打印机则不是。打印文件格式类型的打印机就会打印出你发送给它的打印格式的文件。

在程序中，向设备发送数据非常简单。比如，下面这段代码片段使用低级I/O函数向`/dev/lp0`设备发送缓冲区的内容。

```c
int fd = open (“/dev/lp0”, O_WRONLY);
write (fd, buffer, buffer_length);
close (fd);
```

### 6.4 硬件设备

6.1表中列出了一些能用的块设备。设备编号有明显的模式(比如，第一个SCSI驱动器的第二个分区就是`/dev/sda2`)。这些设备名称在偶尔检查挂载在`/proc/mounts`文件系统中的对应设备是非常有用的。(查看7.5节，"驱动，挂载，文件系统"，获取更多细节)

Table 6.1 placeholder

表6.2列出了一些能用的字符设备

Table 6.2 placeholder



你能通过不止一个字符设备访问某些硬件组件；通常不同的字符设备提供不同的操作。例如，当你使用磁带设备`/dev/ht0`，Linux系统就会在你关闭文件描述符的时候在驱动器里自动重置磁带。你还可以用`/dev/nht0`设备来访问相同的磁带驱动，但是这个设备不会在你关闭文件描述符的时候自动重置磁带。你有时候可能还会看到程序使用`/dev/cua0`或者类似的设备来访问磁带设备；像`/dev/ttyS0`这样的是老的串口访问接口。

有时候你可想直接向字符设备写入数据—比如:

- 终端程序可能会通过串口设备访问调制解调器。数据的写入与读取都是通过调制解调器来向远程计算机传递的。

- 磁带备份程序可能直接向磁带设备写入数据。这个备份程序会自己实现它自己的数据压缩与错误检查格式。

- 程序可以直接向`/dev/tty1`写入数据来达到直接向第一个虚拟终端写入数据的目的。

  终端窗口运行在图形环境或者远程登陆的终端会话中，没有相关联的虚拟终端；代之的是它们关联了一个伪终端。查看6.6节，"PTYs"，查看更多信息。

- 有些时候程序需要访问与其关联的终端设备。

  例如，你的程序需要提示用户的密码。出于安全的考虑，不管用户如何调用这个程序，你可能需要总是忽略掉标准输入输出，只能在终端中读取密码。一种方式就是打开`/dev/tty`，它总是关联到打开它的那个进程的终端设备上。向那个设备写入提示消息，并从其上读取密码。通过忽略标准输入输出，这能防止用户用下面的这种shell语法方式由文件中取出密码再反馈给你的程序。

  > % secure_program < my-password.txt

  如果你需要要你的程序中授权用户，你需要了解一个GNU/Linux PAM 工具。查看10.5节，"授权用户"，了解更多内容。

- 程序可以通过向`/dev/audio`直接发送数据来使用系统声卡播放声音。注意数据必须是Sun音频格式(通常是`.au`扩展名)。

  例如，大多数Linux发行版都有一个经典的声音文件`/usr/share/sndconfig/sample.au`。如果系统中包含了这个文件，可以像下面这样调用命令试着播放这个声音:

  > % cat /usr/share/sndconfig/sample.au > /dev/audio

  如果你想在程序中播放声音，你就得研究各种在Linux系统上可用的相关库和服务了。Gnome窗口环境使用Enlightenment Sound Daemon(EsounD)，详情http://www.tux.org/~ricdude/EsounD.html，KDE窗口环境使用aRts，详情http://space.twc.de/~stefan/kde/arts-mcop-doc/。如果你使用这些声音系统中的其中一个来代替直接向`/dev/audio`写入数据，你的程序也就更好的与其他使用系统声卡的程序相配合工作。

### 6.5 特殊设备

Linux还提供了几个不与任何硬件相对应的字符设备。这些设备入口主设备编号都是1，它们不对应设备驱动，而是对应Linux内核的内存设备。

### 6.5.1 /dev/null

这个`dev/null`设置，是个空设备，非常有用。它的存在有二个目的；第一个你可能非常熟悉:

- Linux会把写入到`/dev/null`的数据全部丢弃。一个大家都知道的小trick就是，在我们不想要输出的情况下，把`/dev/null`做为输出文件，把输出内容都输出到这里。