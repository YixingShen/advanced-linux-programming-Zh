### 管理Linux系统



**6**  设备

**7**  */proc*文件系统

**8**  Linux系统调用

**9**  内联汇编代码

**10** 安全

**11** GNU/Linux示例程序







### 6 设备

Linux系统像其他操作系统一样，内部通过叫做**设备驱动**的模块化的软件组件与硬件进行通信。设备驱动隐藏了操作系统与硬件通信的协议具体细节，同时给系统提供了标准的接口与硬件设备进行通信。

Linux系统下，设备驱动是内核的一部分，既能以静态链接的方式加入内核，也可以按需加载的方式成为内核模块。设备驱动以内核的一部分来运行，并且不会直接访问用户进程。但是Linux系统提供了可以和设备驱动通信的机制—通过一个"类文件对象"—操作硬件。这些文件对象都出现在文件系统中，并且程序也能打开这些文件对象，也可以像正常文件一样进行写操作。无论是通过Linux提供的低级I/O操作还是标准C语言库的I/O操作，都可以通过操作这些"类文件对象"与硬件通信。

Linux也提供几个类文件对象来直接与Linux内核通信，而不是通过设备驱动与Linux内核通信。这些文件不直接与硬件相链接。而是提供多种专门的接口给应用和系统程序。

> **访问设备时要小心!**
>
> 这章讲的技术是直接访问正运行在Linux内核中的设备驱动，并且通过它们来访问连接到系统内的硬件。使用这些技术时需要小心，如果滥用可能会损坏GNU/Linux系统。
>
> *详情看侧边 "块设备的危害"*。

### 6.1 设备类型

设备文件不同于普通文件—它们并不是在文件系统中的一块在磁盘上的数据区域。向设备文件中读取与写入数据相当于与对应的设备驱动通信，再由设备驱动到底层设备。设备文件有二种形态:

- `字符设备`表示这是可以读取或者写入一系列数据字节流的硬件设备。串行和并行接口，磁带设备，终端设备，还有声卡都属于字符设备。
- `块设备`表示这是可以在固定大小的块内读写数据的硬件设备。不像字符设备，块设备提供对存储在设备数据中随机访问功能。磁盘驱动器就是一个块设备。

平常的应用程序都不会用到块设备。虽然磁盘驱动器是块设备，但是每个磁盘分区里的内容通常都包含一个文件系统，同时这个文件系统挂载在GNU/Linux根文件系统树上。只有实现文件系统的内核代码才需要直接访问块设备；应用程序访问磁盘上的内容都是通过标准文件和目录来完成。

> **块设备危害**
>
> 块设备提供了直接访问磁盘驱动器数据的功能。即使大多数GNU/Linux系统都设置了非根进程不能直接访问这些设备，但是根进程还是可以通过改写磁盘上的内容对块设备造成严重危害。通过向磁盘块设备写入内容，程序可以修改或者毁掉文件系统控制信息，甚至是磁盘分区表和主启动记录，这样就直接导致驱动或者整个系统全部瘫痪。访问这些设备时一定要非常小心。

应用程序有时候会使用字符设备，接下来几节我们会讨论关于字符设备的内容。

### 6.2 设备编号

Linux标识设备使用二个数字: `主设备编号`和`次设备编号`。主设备编号用来表示哪个驱动对应哪个设备。对应主设备编号的驱动是固定写在内核代码中的。注意相同的主设备编号可能对应二个不同的设备，一个字符设备一个是块设备。次设备编号用来辨别单独的设备或者单独由一个驱动来控件的组件。

比如，主设备编号为3的对应系统中的主IDE控制器。IDE控制器可以有二个设备(磁盘，磁带，或者CD-ROM驱动器)附加在里面；"主"设备有一个次设备编号为0，"从"设备有一个次设备编号是64。"主"设备上单独的分区(假设设备支持分区)依次由次设备编号1，2，3这样类推。"从"设备上单独的分区依次由次设备编号65，66，67这样类推。

主设备编号都列在Linux内核代码文档中。在多数的GNU/Linux发行版中，可以在`usr/src/linux/Documention/devices.txt`中找到。`/proc/devices`这个特殊的入口列出了当前内核已加载的设备与驱动相对应的主设备编号(查看第七章，"/proc 文件系统"，获得更多关于`/proc`文件系统的入口)。

###  6.3 设备入口

设备入口很多时候都一个标准的文件。你可以用`mv`命令移动这个文件，也可以用`rm`命令删除这个文件。如果你用`cp`命令拷贝这个文件，其实就是从设备中读取字节数据(假设这个设备支持读取)再写入到目标文件。如果你想覆盖设备入口，你只需要向对应的设备写入字节数据即可。

你可以用`mknod`命令(使用`man 1 mknod`查看手册)或者调用`mknod`系统函数(使用`man 2 mknod`查看手册)在文件系统中创建设备入口。在文件系统中创建设备入口并不会自动让到对应的设备驱动或者硬件设备立即可用；如果有了设备入口，这仅仅是与驱动器通信的入口。只有超级用户进程才能通过`mknod`命令或者`mknod`系统调用创建块设备和字符设备。

使用`mknod`命令创建设备，第一个参数指定入口文件在文件系统中的路径。第二个参数，`b`表示是块设备，`c`表示是字符设备。第三个和第四个参数分别对应主设备编号与次设备编号。例如下这个命令创建一个字符设备入口，名字是`lp0`，路径是当前目录，主设备编号是6，次设备编号是0。这些数字表示Linux系统上的第一个并行端口。

```shell
% mknod ./lp0 c 6 0
```

记住只有超级用户进程能创建字符设备与块设备。所以你必须以`root`用户登陆才能成功调用这个命令。

`ls`命令用来显示指定的设备入口。如果你用`ls`命令的时候带了`-l`或者`-o`选项，那么命令每行的输入第一个字符就表示当前入口的类型。记住`-`(中划线)表示是标准文件，`d`表示是目录。类似，`b`表示块设备，`c`表示字符设备。`ls`还会在平常普通文件输出文件大小的位置输出主设备编号与次设备编号。举例，可以看一下刚才我们创建的块设备:

> % ls -l lp0
> crw-r-----    1 root     root       6,   0 Mar  7 17:03 lp0

在程序中，你可以通过`stat`确定文件系统入口是块设备还是字符设备，并获取其设备编号。可以在附录B中查看B.2小节，"stat"。

移除设备入口使用`rm`。这并不会删除设备或者设备驱动；只是简单的移除文件系统中的设备入口。

> % rm ./lp0

### 6.3.1 /dev 目录

按惯例，GNU/Linux系统在会`/dev`目录下包含全部Linux已知的字符设备与块设备入口。在`/dev`目录下的所有入口都由标准的设备名字与主次设备编号组成。

例如，主设备包含主IDE控制器，其主次设备编号分别是3和0，有一个标准名字是`/dev/hda`。如果这个设备支持分区，其中第一块分区的次设备编号就是1，标准名字就是`/dev/hda1`。你可以在你自己的系统上检查一下:

> % ls -l /dev/hda /dev/hda1
> brw-rw----    1 root     disk       3,   0 May  5  1998 /dev/hda
> brw-rw----    1 root     disk       3,   1 May  5  1998 /dev/hda1

同样的，`/dev`还有一个我们之前用的的并行端口字符设备:

> % ls -l /dev/lp0
> crw-rw----    1 root     daemon     6,   0 May  5  1998 /dev/lp0

大多数情况你不需要自己调用`mknod`创建设备入口，直接使用`/dev`下的入口就可以了。非超级用户别无选择，因为不能自己创建设备入口，只能使用先前存在的设备入口。通常只有系统管事员与开发者在在特殊的硬件上工作的时候才需要创建设备入口。大多数GNU/Linux系统发行版都包含了工具帮助管理员创建正确名字的标准设备入口。

### 6.3.2 通过打开文件访问设备

你如何使用这些设备?比如字符设备，使用它十分简单:就像打开正常文件一样打开这个设备，然后向其中读写就可以了。你甚至可以用普通文件用的`cat`命令，或者你所使用shell的重定向语法，向这个设备发送数据或者读取数据。

举例说明，假设现在你电脑的第一个并行商品上连接了一个打印机，你可以直接向`/dev/lp0`发送文件，就可以所文件打印出来了。假设要打印的内容在`document.txt`文件中，则可以像下面这样调用:

> % cat document.txt > /dev/lp0

前提是你必须有向这个设备入口写入的权限，这个操作才会成功；在多数GNU/Linux系统中，只有`root`用户和打印机守护进程(`lpd`)才有权限向这个设备入口写入文件。同时你向打印机发送了什么内容，打印机就会打印出什么内容。有些打印机会打印出发送给它的普通无格式文本，而有些打印机则不是。打印文件格式类型的打印机就会打印出你发送给它的打印格式的文件。

在程序中，向设备发送数据非常简单。比如，下面这段代码片段使用低级I/O函数向`/dev/lp0`设备发送缓冲区的内容。

```c
int fd = open (“/dev/lp0”, O_WRONLY);
write (fd, buffer, buffer_length);
close (fd);
```

### 6.4 硬件设备

6.1表中列出了一些能用的块设备。设备编号有明显的模式(比如，第一个SCSI驱动器的第二个分区就是`/dev/sda2`)。这些设备名称在偶尔检查挂载在`/proc/mounts`文件系统中的对应设备是非常有用的。(查看7.5节，"驱动，挂载，文件系统"，获取更多细节)

Table 6.1 placeholder

表6.2列出了一些能用的字符设备

Table 6.2 placeholder



你能通过不止一个字符设备访问某些硬件组件；通常不同的字符设备提供不同的操作。例如，当你使用磁带设备`/dev/ht0`，Linux系统就会在你关闭文件描述符的时候在驱动器里自动重置磁带。你还可以用`/dev/nht0`设备来访问相同的磁带驱动，但是这个设备不会在你关闭文件描述符的时候自动重置磁带。你有时候可能还会看到程序使用`/dev/cua0`或者类似的设备来访问磁带设备；像`/dev/ttyS0`这样的是老的串口访问接口。

有时候你可想直接向字符设备写入数据—比如:

- 终端程序可能会通过串口设备访问调制解调器。数据的写入与读取都是通过调制解调器来向远程计算机传递的。

- 磁带备份程序可能直接向磁带设备写入数据。这个备份程序会自己实现它自己的数据压缩与错误检查格式。

- 程序可以直接向`/dev/tty1`写入数据来达到直接向第一个虚拟终端写入数据的目的。

  终端窗口运行在图形环境或者远程登陆的终端会话中，没有相关联的虚拟终端；代之的是它们关联了一个伪终端。查看6.6节，"PTYs"，查看更多信息。

- 有些时候程序需要访问与其关联的终端设备。

  例如，你的程序需要提示用户的密码。出于安全的考虑，不管用户如何调用这个程序，你可能需要总是忽略掉标准输入输出，只能在终端中读取密码。一种方式就是打开`/dev/tty`，它总是关联到打开它的那个进程的终端设备上。向那个设备写入提示消息，并从其上读取密码。通过忽略标准输入输出，这能防止用户用下面的这种shell语法方式由文件中取出密码再反馈给你的程序。

  > % secure_program < my-password.txt

  如果你需要要你的程序中授权用户，你需要了解一个GNU/Linux PAM 工具。查看10.5节，"授权用户"，了解更多内容。

- 程序可以通过向`/dev/audio`直接发送数据来使用系统声卡播放声音。注意数据必须是Sun音频格式(通常是`.au`扩展名)。

  例如，大多数Linux发行版都有一个经典的声音文件`/usr/share/sndconfig/sample.au`。如果系统中包含了这个文件，可以像下面这样调用命令试着播放这个声音:

  > % cat /usr/share/sndconfig/sample.au > /dev/audio

  如果你想在程序中播放声音，你就得研究各种在Linux系统上可用的相关库和服务了。Gnome窗口环境使用Enlightenment Sound Daemon(EsounD)，详情http://www.tux.org/~ricdude/EsounD.html，KDE窗口环境使用aRts，详情http://space.twc.de/~stefan/kde/arts-mcop-doc/。如果你使用这些声音系统中的其中一个来代替直接向`/dev/audio`写入数据，你的程序也就更好的与其他使用系统声卡的程序相配合工作。

### 6.5 特殊设备

Linux还提供了几个不与任何硬件相对应的字符设备。这些设备入口主设备编号都是1，它们不对应设备驱动，而是对应Linux内核的内存设备。

### 6.5.1 /dev/null

这个`dev/null`设置，是个空设备，非常有用。它的存在有二个目的；第一个你可能非常熟悉:

- Linux会把写入到`/dev/null`的数据全部丢弃。一个大家都知道的小trick就是，在我们不想要输出的情况下，把`/dev/null`做为输出文件，把输出内容都输出到这里。

  例如，运行一个命令并丢弃它所有的输出(不输出也不写入文件)，重定向标准输出到`/dev/null`就行了:

  > % verbose_command > /dev/null

- 从`/dev/null`中读取出来的结果总是文件结束符。例如，假如你使用`open`命令打开了指向`/dev/null`的一个文件描述符，并尝试使用`read`命令从文件中读取内容，`read`命令总是读到空数据并返回0。如果你从`/dev/null`设备中拷贝内容到另一个文件，目标文件将会是0长度的文件。

  > % cp /dev/null empty-file
  > % ls -l empty-file
  > -rw-rw----    1 samuel   samuel          0 Mar  8 00:27 empty-file


### 6.5.2 /dev/zero

`/dev/zero`这个设备就类似于它是一个无限长的文件，内容全都以0来填充。你想在`/dev/zero`设备中读取多少数据，Linux系统就会生成多少字节0的数据。

为了证明这个，我们运行一下在十六进制的dump程序，它列在了附录B"读取数据"，表B.4的B.1.4节中，这个程序会以十六进制的形式打印文件内容。

> % ./hexdump /dev/zero
> 0x000000 : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
> 0x000010 : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
> 0x000020 : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
> 0x000030 : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 

确认之后使用Ctrl + C停止，不然会不停继续下去。

内存映射`/dev/zero`是内存内存分配的高级技术。可以查看第五章"进程内通信"，5.3.5节，"`mmap`的其他用处"，获取更多细节。

### 6.5.3 /dev/full

`/dev/full`类似于一个文件在文件系统中没有空间了。向`/dev/full`写入失败同时会设置`errno`为ENOSPC，通常就表示正在写入的设备已经满了。

例如，你可以试着用`cp`命令向`/dev/full`设备写入内容:

> % cp /etc/fstab /dev/full
> cp: /dev/full: No space left on device

`/dev/full`设备主要用于测试你的程序在磁盘空间不足时还写入文件时的表现。

### 6.5.4 随机数设备

二个特殊的设备`/dev/random`和`/dev/urandom`，提供了访问Linux内核内置的随机数生成工具。

大多数软件生成的随机数，例如C标准库中的`rand`函数，实际上都是`伪随机数`。即使这些生成的数字满足一些随机数的要求，但是这些随机数都是可以重复出现的：如果你用相同的种子值，每次都会得到相同的"伪随机序列"。这些行为都是不可避免的，因为计算机本身就是确定的，可预见的。对某些程序，这种行为是造成的影响非常不好；比如你能获取到加密算法中生成的随机数序列，你就可以破解加密算法。

为了在计算机中获取到更好的随机数，就是需要一个额外的随机源。Linux系统有一个特别好的随机源:那就是使用Linux的你！通过计算你输入动作的延时，比如击键和鼠标移动这些动作，Linux足以根据这些获取到不可预知的高质量的随机数字节流。你可以通过访问`/dev/random`和`/dev/urandom`设备来获取这些字节流。你读到的数据就是这些随机生成的字节流。

这二个设备的差异表现在耗尽Linux系统的随机存储的时候。如果你试着在`/dev/random`读取非常多的字节数据，但却不要有任何的输入动作发生(不敲键盘，不移动鼠标，也不做任何类似的操作)，Linux就会锁定读取操作。只有你再次提供了一些随机的动作让Linux生成更多的随机字节数据的时候，才会把这些随机数据返回给你的程序。

举例子，试着用`od`命令显示`/dev/random`设备的内容，每行输出显示16个随机字节。

> % od -t x1 /dev/random 
> 0000000 2c 9c 7a db 2e 79 3d 65 36 c2 e3 1b 52 75 1e 1a
> 0000020 d3 6d 1e a7 91 05 2d 4d c3 a6 de 54 29 f4 46 04
> 0000040 b3 b0 8d 94 21 57 f3 90 61 dd 26 ac 94 c3 b9 3a
> 0000060 05 a3 02 cb 22 0a bc c9 45 dd a6 59 40 22 53 d4

你看到的输出的行数可能不太一样—会有不少—但是一旦Linux耗尽存储的随机源，就会立刻停止输出。这个时候试着敲几下键盘，动几下鼠标，就会有更多的随机数出现。如果想到更好的随机源，那就让你的猫在你键盘上溜达一会儿。

与`/dev/random`不同的是，从`/dev/urandom`读取字节流从不会锁定。如果Linux的随机源耗尽，就会使用一个加密算法来根据旧的随机字节序列来生成新的"伪随机数"。这样生成的随机数已经可以就会大数的情况了，这些生成的随机数并不像在`/dev/random`中获得的那样通过严格的随机性测试。

举例，你使用如下命令，随机字节流就会不停的产生，直到按下Ctrl+C停止这个程序:

> % od -t x1 /dev/urandom
> 0000000 62 71 d6 3e af dd de 62 c0 42 78 bd 29 9c 69 49
> 0000020 26 3b 95 bc b9 6c 15 16 38 fd 7e 34 f0 ba ce c3
> 0000040 95 31 e5 2c 8d 8a dd f4 c4 3b 9b 44 2f 20 d1 54
>
> ...

